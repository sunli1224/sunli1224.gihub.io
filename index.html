<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="总结分享的个人博客平台">
<meta property="og:type" content="website">
<meta property="og:title" content="bblike博客小站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bblike博客小站">
<meta property="og:description" content="总结分享的个人博客平台">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="孙力">
<meta property="article:tag" content="技术分享">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>bblike博客小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bblike博客小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

<!-- 加入APlayer音乐播放器 -->
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bblike博客小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">bblikeBoy</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-fw fa-comment"></i>留言版</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">zookeeper学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-16 23:39:55" itemprop="dateCreated datePublished" datetime="2021-06-16T23:39:55Z">2021-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 08:46:22" itemprop="dateModified" datetime="2021-06-17T08:46:22Z">2021-06-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p><strong>zookeeper是开源的分布式的、为分布式应用提供协调服务的Apache项目。</strong></p>
<p>​     zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责</p>
<p>存储和管理大家关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，zookeeper就</p>
<p>将负责通知已经在zookeeper上注册的那些观察者做出相应的反应。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_00-46-15.png" alt></p>
<p><strong>注意：</strong>了解了zookeeper的工作机制，我们就可以将zookeeper类比为<strong>文件系统+通知机制</strong></p>
<h4 id="zookeeper特点"><a href="#zookeeper特点" class="headerlink" title="zookeeper特点"></a>zookeeper特点</h4><p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_00-52-18.png" alt></p>
<p>1、zookeeper： 一个领导者（Leader），多个跟随者（Follower）组成的集群。</p>
<p>2、集群中只要半数以上节点存活，zookeeper集群就能正常服务。</p>
<p>3、全局数据一致性： 每个server保存一份相同的数据副本，client无论连接到那个</p>
<p>server，数据都是一致。</p>
<p>4、更新请求顺序进行，来自同一个client的更新请求按其顺序发送依次执行。</p>
<p>5、数据更新原子性，一次数据更新要么成功，要么失败。</p>
<p>6、实时性，在一定时间范围内，client能读到最新数据。</p>
<h4 id="zookeeper数据结构"><a href="#zookeeper数据结构" class="headerlink" title="zookeeper数据结构"></a>zookeeper数据结构</h4><p>​     zookeeper的数据模型的结构与unix文件系统类似，整体可以看做是一颗树，每个节点称作一个znode。</p>
<p>每个znode默认能够存储1MB的数据，每个znode都可以通过其路径唯一标识。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_01-06-38.png" alt></p>
<h4 id="zookeeper应用场景"><a href="#zookeeper应用场景" class="headerlink" title="zookeeper应用场景"></a>zookeeper应用场景</h4><p>​    提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务节点动态上下线、软负载均衡等。</p>
<p><strong>统一名称服务</strong></p>
<p>​    在分布式环境下，经常需要对服务应用/服务进行统一命名，便于识别。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_14-50-41.png" alt></p>
<p><strong>统一配置管理</strong></p>
<p>（1）分布式环境下，配置文件同步非常常见。</p>
<p>​       1、一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群。</p>
<p>​       2、对配置文件修改后，希望能够快速同步到各个节点上。</p>
<p>（2）配置管理可交由zookeeper实现。</p>
<p>​        1、可将配置信息写入zookeeper上的一个ZNode。</p>
<p>​        2、各个客户端服务监听这个ZNode。</p>
<p>​        3、一旦Znode中的数据被修改，zookeeper将通知各个客户服务器。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_14-56-56.png" alt></p>
<p><strong>统一集群管理</strong></p>
<p>（1） 分布式环境中，实时掌握每个节点的状态是必要的。</p>
<p>​         1、可根据节点实时状态做出一些调整</p>
<p>（2）zookeeper可以实现实时监控节点状态变化</p>
<p>​        1、可将节点信息写入zookeeper上的一个ZNode。</p>
<p>​        2、监听这个ZNode可获得它的实时状态变化。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_14-50-41.png" alt></p>
<p><strong>服务器动态上下线</strong></p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_15-04-16.png" alt></p>
<p><strong>软负载均衡</strong></p>
<p>​       在zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。</p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_15-05-46.png" alt></p>
<h4 id="zookeeper命令"><a href="#zookeeper命令" class="headerlink" title="zookeeper命令"></a>zookeeper命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单体启动zookeeper服务</span></span><br><span class="line">./zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查zookeeper服务是否启动成功， 出现名称为 QuorumPeerMain ，说明启动成功</span></span><br><span class="line">jps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看zookeeper状态</span></span><br><span class="line">./zkServer.sh status</span><br><span class="line"> </span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/zookeeper-3.4.14/bin/../conf/zoo.cfg</span><br><span class="line">Mode: standalone</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端连接zookeeper</span></span><br><span class="line"> ./zkCli.sh -server localhost:2181</span><br></pre></td></tr></table></figure>



<p><strong>zookeeper配置参数含义</strong></p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_16-03-15.png" alt></p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_16-05-48.png" alt></p>
<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_16-07-40.png" alt></p>
<h4 id="zookeeper内部原理"><a href="#zookeeper内部原理" class="headerlink" title="zookeeper内部原理"></a>zookeeper内部原理</h4><p><strong>选举机制</strong></p>
<p>1、半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合安装奇数台服务器。</p>
<p>2、zookeeper虽然在配置文件并没有指定Master和Slave。但是，Zookeeper工作时，是一个</p>
<p>节点为Leader，其他则为Follwer，Leader是通过内部内部的选举机制临时产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。在分析选举原理前，先介绍几个重要的参数。</span><br><span class="line"></span><br><span class="line">服务器 ID(myid)：编号越大在选举算法中权重越大</span><br><span class="line">事务 ID(zxid)：值越大说明数据越新，权重越大</span><br><span class="line">逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</span><br><span class="line">选举状态：</span><br><span class="line"></span><br><span class="line">LOOKING: 竞选状态</span><br><span class="line">FOLLOWING: 随从状态，同步 leader 状态，参与投票</span><br><span class="line">OBSERVING: 观察状态，同步 leader 状态，不参与投票</span><br><span class="line">LEADING: 领导者状态</span><br><span class="line">1、服务器启动时的 leader 选举</span><br><span class="line">每个节点启动的时候都 LOOKING 观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器 server1启动时，无法进行 leader 选举，当第二台服务器 server2 启动时，两台机器可以相互通信，进入 leader 选举过程。</span><br><span class="line"></span><br><span class="line">（1）每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器。</span><br><span class="line"></span><br><span class="line">（2）接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器。</span><br><span class="line"></span><br><span class="line">（3）分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</span><br><span class="line"></span><br><span class="line">a. 优先比较 epoch</span><br><span class="line">b. 检查 zxid，zxid 比较大的服务器优先作为 leader</span><br><span class="line">c. 如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器</span><br><span class="line">（4）统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点。</span><br><span class="line"></span><br><span class="line">（5）改变服务器状态。一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、运行过程中的 leader 选举</span><br><span class="line">当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</span><br><span class="line"></span><br><span class="line">（1）变更状态。leader 挂后，其他非 Oberver服务器将自身服务器状态变更为 LOOKING。</span><br><span class="line">（2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。</span><br><span class="line">（3）处理投票。规则同启动过程。</span><br><span class="line">（4）统计投票。与启动过程相同。</span><br><span class="line">（5）改变服务器状态。与启动过程相同。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/17/zookeeper%E5%AD%A6%E4%B9%A0/Snipaste_2021-06-17_16-45-44.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/26/JVM%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/JVM%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JVM学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-26 01:58:38" itemprop="dateCreated datePublished" datetime="2021-05-26T01:58:38Z">2021-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-01 05:18:25" itemprop="dateModified" datetime="2021-06-01T05:18:25Z">2021-06-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/26/JVM%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/26/JVM%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h3><p>所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令，大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<p>vmware就是属于系统虚拟机，它完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</p>
<p>程序虚拟机的典型代表就是java虚拟机，它专门为执行单个计算机程序而设计，在java虚拟机中执行的指令我们称为java字节码指令。</p>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供资源。</p>
<p>作用：<br>java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行，</p>
<p>每一条java指令，java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放哪里</p>
<p>。</p>
<p>特点：</p>
<p>1、一次编译，到处运行</p>
<p>2、自动内存管理</p>
<p>3、自动垃圾回收</p>
<p><strong>JVM位置：</strong></p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_02-14-38.png)</p>
<p><strong>JVM整体结构：</strong></p>
<p>hotSpot VM是目前市面上高性能虚拟机的代表之一</p>
<p>它采用解释器与即时编译器并存的架构</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_02-20-09.png)</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_10-10-25.png)</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_10-15-24.png)</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_10-32-36.png)</p>
<p><strong>加载：</strong></p>
<p>1、通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2、将这个字节流所代表的静态存储结构转换为方法区的运行时</p>
<p>数据结构</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为</p>
<p>方法区这个类的各种数据的访问入口</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_10-59-24.png)</p>
<p><strong>链接：</strong></p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_11-08-10.png)</p>
<p><strong>初始化：</strong></p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_11-33-23.png)</p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_10-34-24.png)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/26/kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/kafka/" class="post-title-link" itemprop="url">kafka</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-25 19:52:05" itemprop="dateCreated datePublished" datetime="2021-05-25T19:52:05Z">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 09:30:15" itemprop="dateModified" datetime="2021-05-27T09:30:15Z">2021-05-27</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/26/kafka/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/26/kafka/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>920</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>分布式的基于发布/订阅模式的消息队列</p>
<p>消息队列异步处理任务</p>
<p>1、解耦</p>
<p>2、流量削峰</p>
<p>3、缓冲</p>
<p>4、可恢复性</p>
<p>5、灵活性</p>
<p>6、异步处理能力</p>
<p>消息队列的两种模式</p>
<p>1、点对点模式  一对一模式</p>
<p>2、发布与订阅模式 一对多模式</p>
<p>producer   — 消息推送  —- topic（阻塞队列） —-  广播的形式发送到订阅的消费者中去 —- 多个消费者（消费者必须采取轮训的方式去查看topic中是否存在消息未消费）</p>
<p><strong>kafka架构</strong></p>
<p>![](D:\npm Registry\ss\source_posts\kafka\Snipaste_2021-05-25_19-54-42.png)</p>
<p>1、producer: 消息生产者，就是向kafka broker （分区）发送消息</p>
<p>2、consumer： 消息消费者，向kafka broker 取消息的客户端</p>
<p>3、consumer group： 消费者组，由多个consumer组成。</p>
<p><strong>一个消费者组里面的消费者只能消费不同分区的topic消息。</strong></p>
<p>创建topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181  --topic test --partitions 1  -replication-factor 1</span><br><span class="line"></span><br><span class="line">创建副本数不能超过基数</span><br></pre></td></tr></table></figure>

<p>查看topic总数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<p>删除topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure>

<p>topic描述</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure>

<p>默认端口号9092</p>
<p>发送消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic first --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">集群接收消息</span><br><span class="line">bin/kafka-console-consumer.sh --topic first --bootstrap-server localhost:9092 --from-beginning</span><br></pre></td></tr></table></figure>





<p><strong>kafka工作区流程：</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/23/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/23/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">mysql性能优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-22 16:40:19" itemprop="dateCreated datePublished" datetime="2021-05-22T16:40:19Z">2021-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 09:47:50" itemprop="dateModified" datetime="2021-06-07T09:47:50Z">2021-06-07</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/23/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/23/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql性能优化"><a href="#mysql性能优化" class="headerlink" title="mysql性能优化"></a>mysql性能优化</h1><h2 id="mysql-逻辑架构"><a href="#mysql-逻辑架构" class="headerlink" title="mysql 逻辑架构"></a>mysql 逻辑架构</h2><p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-24_10-06-25.png)</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-24_10-10-34.png)</p>
<p>如何查看现有的mysql使用什么数据引擎？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>

<p>mysql默认的存储引擎是innodb</p>
<table>
<thead>
<tr>
<th align="center">对比项</th>
<th align="center">myisam</th>
<th align="center">innodb</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">行表锁</td>
<td align="center">表锁，即使操作一条记录也会锁住整张表，不适合高并发</td>
<td align="center">行锁，操作某一行，不会对其他行有影响，适合高并发。</td>
</tr>
<tr>
<td align="center">缓存</td>
<td align="center">只缓存索引</td>
<td align="center">不仅可以缓存索引还要缓存真实数据，对内存要求较高，而内存大小会有决定性的影响。</td>
</tr>
<tr>
<td align="center">表空间</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">关注点</td>
<td align="center">性能（适合只读表）</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">默认安装</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="sql性能下降的原因？"><a href="#sql性能下降的原因？" class="headerlink" title="sql性能下降的原因？"></a>sql性能下降的原因？</h3><p>1、查询语句写的烂，可能涉及多次的关联查询、子查询，导致sql性能下降。</p>
<p>2、索引失效（单值、复合）</p>
<p>3、关联查询涉及太多join</p>
<p>4、服务器调优以及各个参数的设置（缓冲、线程等）</p>
<h3 id="sql执行加载顺序"><a href="#sql执行加载顺序" class="headerlink" title="sql执行加载顺序?"></a>sql执行加载顺序?</h3><p>   mysql在执行sql时，不会按照人写的sql顺序进行解析，而是通过mysql的服务层里面的sql的优化器，解析sql的顺序执行sql语句，使得sql的执行效率更高。</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-24_10-47-40.png)</p>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>​    mysql官方对索引的定义为：索引（Index）是帮助mysql高效获取数据的数据结构。可以得到索引的本质：索引是数据结构，可以简单理解为排好序的快速查找数据结构。</p>
<p>​     一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引</p>
<p>​        在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据</p>
<p>，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构，就是索引。其中聚集索引、次要索引、复合索引、前缀索引、唯一索引默认都是使用B加树索引，但是除了B数索引，还有哈希索引。</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-24_14-23-46.png)</p>
<p>​                                    左边是数据表，一共两列七条记录，最左边的是数据记录的物理地址。</p>
<p>​      为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<h3 id="索引的优势和劣势？"><a href="#索引的优势和劣势？" class="headerlink" title="索引的优势和劣势？"></a>索引的优势和劣势？</h3><p><strong>优势：</strong> </p>
<p>类似于大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</p>
<p>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</p>
<p><strong>劣势：</strong></p>
<p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间的。</p>
<p>虽然索引大大提高了查询速度，同时会降低更新表的速度，如对表进行insert、update和delete，因为更新表时，</p>
<p>mysql不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变换后的索引信息。</p>
<p>索引只是提高了效率的一个因素，入股你的mysql有大数据量的表，就需要花时间研究建立最优秀的索引，或者优化索引。</p>
<h4 id="索引类型有哪些？"><a href="#索引类型有哪些？" class="headerlink" title="索引类型有哪些？"></a>索引类型有哪些？</h4><p>1、单值索引  即一个索引只包含单个列，一个表可以有多个单列索引</p>
<p>2、唯一索引 索引列的值必须唯一，但允许有空值</p>
<p>3、复合索引 即一个索引包含多个列</p>
<p><strong>基本语法：</strong></p>
<p>创建</p>
<p>1、</p>
<p> create [unique] index indexName on tableName(colName(length))</p>
<p>2、</p>
<p>alter tableName add [unique] index [indexName] on (colName(length))</p>
<p>删除</p>
<p>1、</p>
<p>drop index [indexName] on tableName</p>
<p>查看索引</p>
<p>show index from table_name\G </p>
<h5 id="mysql-索引结构"><a href="#mysql-索引结构" class="headerlink" title="mysql 索引结构"></a>mysql 索引结构</h5><p>BTree索引</p>
<p>Hash索引</p>
<p>full-text全文索引</p>
<p>R-Tree索引</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-25_09-16-25.png)</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-25_09-17-30.png)</p>
<h5 id="哪些情况需要创建索引？"><a href="#哪些情况需要创建索引？" class="headerlink" title="哪些情况需要创建索引？"></a>哪些情况需要创建索引？</h5><p>1、主键自动建立唯一索引</p>
<p>2、频繁作为查询条件的字段应该创建索引</p>
<p>3、查询中与其他关联表的字段，外键关系建立索引</p>
<p>4、频繁更新的字段不适合创建索引</p>
<p>因为每次更新不单是更新数据而且索引也要更新</p>
<p>5、where条件里面用不到的字段不创建索引</p>
<p>6、单值/组合索引的选择问题（高并发条件下建立组合索引）</p>
<p>7、查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</p>
<p>8、查询中统计或者分组字段</p>
<h5 id="哪些情况下不需要建立索引？"><a href="#哪些情况下不需要建立索引？" class="headerlink" title="哪些情况下不需要建立索引？"></a>哪些情况下不需要建立索引？</h5><p>1、表记录太少</p>
<p>2、经常增删改的表</p>
<p>3、数据重复且分布的表字段，因此应该只为最经常查询和最经常排序</p>
<p>建立索引，注意：如果某个数列包含许多重复的内容，为它建立索引就</p>
<p>没有太大的实际效果。</p>
<p>​      假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布大概大约为</p>
<p>50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p>
<p>​      索引的选择性是指索引列中不同值的数目与表中记录数的比，如果有一个表中有2000条</p>
<p>记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。</p>
<p>一个索引的选择性越接近1，这个·索引的效率就越高。</p>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>1、通过mysql query Optimizer</p>
<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-25_10-48-57.png)</p>
<p>2、mysql常见瓶颈</p>
<p>cpu： 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。</p>
<p>IO： 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候。</p>
<p>服务器硬件性能瓶颈： top。free，iostat和vmstat来查看系统的性能状态。</p>
<p>3、Explain（mysql执行计划）</p>
<p>使用explain关键字可以模拟优化器执行sql查询语句，从而直到mysql是如何处理</p>
<p>你的sql语句。分析你的查询语句或是表结构的性能瓶颈。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> + <span class="keyword">sql</span> 语句</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> city_weather;</span><br></pre></td></tr></table></figure>

<p>![](D:\npm Registry\ss\source_posts\mysql性能优化\Snipaste_2021-05-25_11-09-30.png)</p>
<p><strong>参数：</strong></p>
<p><strong>id：</strong></p>
<p>select 查询的序列号，包含数字，表示查询中执行select字句或操作表的顺序</p>
<p>1、id相同，执行顺序由上至下</p>
<p>2、id不同，如果子查询，id序号会递增，id值越大优先级越高，越先被执行。</p>
<p>3、id相同不同，同时存在</p>
<p>id如果相同，可以认为是一组，从上往下顺序执行；</p>
<p>在所有组中，id值越大，优先级越高，越先执行</p>
<p><strong>select_type:</strong></p>
<p>查询的类型，主要用于区别</p>
<p>普通查询、联合查询、子查询等复杂查询</p>
<p><strong>SIMPLE：</strong></p>
<p>简单的select查询，查询中不包含子查询或者union</p>
<p><strong>PRIMARY:</strong></p>
<p>查询中若包含任何复杂的子部分，最外层查询则被标记为</p>
<p><strong>SUBQUERY:</strong></p>
<p>在select或where列表中包含了子查询</p>
<p><strong>DERIVED:</strong></p>
<p>在from列表中包含的子查询被标记为derived（衍生）</p>
<p>mysql会递归执行这些子查询，把结果放在临时表里</p>
<p><strong>UNION:</strong></p>
<p>若第二个select出现在union之后，则被标记为union</p>
<p>若union包含在from子查询中，外层select将被标记为：derived</p>
<p><strong>UNION RESULT:</strong></p>
<p>从union表中获取结果的select</p>
<p><strong>table：</strong></p>
<p>显示这一行的数据是关于哪张表的</p>
<p><strong>type:</strong> </p>
<p>访问类型</p>
<p>是较为重要的一个指标，结果值从最好到最坏依次是：</p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_merge&gt;unique_subquery&gt;range&gt;index&gt;ALL</p>
<p>显示查询使用了任何类型：</p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref</p>
<p><strong>system：</strong></p>
<p>表只有一行记录，这是const类型的特列，平均不会出现，这个可以忽略不计。</p>
<p><strong>const:</strong> </p>
<p>表示通过索引一次就找到了，const用于比较primary_key或者unique索引。因为只匹配一行数据，所以</p>
<p>很快如将主键置于where列表中，mysql就能将该查询转换成一个常量。</p>
<p><strong>possible_keys</strong><br>指出 MySQL 使用哪个索引在该表找到行记录。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能</p>
<p><strong>key</strong><br>显示 MySQL 实际使用的索引。如果为 NULL，则没有使用索引查询<br><strong>key_len</strong><br>表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度<br><strong>ref</strong><br>显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值<br><strong>rows</strong><br>根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好<br><strong>filtered</strong><br>返回结果的行数占读取行数的百分比，值越大越好<br><strong>extra</strong><br>  包含不适合在其他列中显示但十分重要的额外信息。常见的值如下</p>
<p>  <strong>using filesort</strong><br>  MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取<br>  若出现有该值，应该优化SQL语句<br>  <strong>using temporary</strong><br>  使用临时表保存中间结果，比如，MySQL在对查询结果排序时使用临时表<br>  常见于order by和group by<br>  若出现有该值，应该优化SQL语句<br>  <strong>using index</strong><br>  表示select操作使用了覆盖索引，避免了访问表的数据行，效率不错<br>  <strong>using where</strong><br>  where 子句用于限制哪一行<br>  <strong>using join buffer</strong><br>  使用连接缓存<br>  <strong>distinct</strong><br>  发现第一个匹配后，停止为当前的行组合搜索更多的行</p>
<p>  <strong>impossible where</strong></p>
<p>  where 子句总是false，不能用来获取任何元祖</p>
<p><strong>sql优化步骤</strong></p>
<p>1、观察，至少跑一天，看看生产环境的慢sql情况</p>
<p>2、开启慢查询日志，设置阀值，比如超过5秒钟的就是</p>
<p>慢sql，并将它抓取出来</p>
<p>3、explain + 慢sql分析</p>
<p>4、show profile</p>
<p>5、运维经理 or DBA，进行sql数据库服务器参数调优</p>
<p>========================</p>
<p>1、慢查询的开启和捕获</p>
<p>2、explain + 慢sql分析</p>
<p>3、show profile 查询sql在mysql服务器里面</p>
<p>的执行细节和生命周期</p>
<p>4、sql数据库服务器参数调优</p>
<p><strong>小表驱动大表</strong></p>
<p>select * from A where id in (select id from B)</p>
<p>等价于</p>
<p>for select id from B</p>
<p>for select * from A where A.id = B.id;</p>
<p><strong>当B表的数据小于A表数据集时， 用in 优于exists</strong></p>
<p>select * from A where exists （select 1 from B where B.id = A.id）</p>
<p>for  select * from A</p>
<p>for select * from B where B.id = A.id;</p>
<p><strong>当A表的数据集小于B表的数据集时，用于exists优于in</strong></p>
<p><strong>注意： A表和B表的ID应该建立索引</strong></p>
<p><strong>exists</strong></p>
<p>select … from table where exists(subquery)</p>
<p>将主查询的数据，放到子查询中做条件，</p>
<p>根据验证结果来决定主查询的数据结果是否可以保留</p>
<p><strong>慢查询日志：</strong></p>
<p><strong>show profile:</strong></p>
<h4 id="mysql锁理论："><a href="#mysql锁理论：" class="headerlink" title="mysql锁理论："></a>mysql锁理论：</h4><h1 id="mysql-ACID执行原理"><a href="#mysql-ACID执行原理" class="headerlink" title="mysql ACID执行原理"></a><strong>mysql ACID执行原理</strong></h1><p>mysql 的acid指的是 原子性、持久性、隔离性、一致性</p>
<p><strong>原子性：</strong> </p>
<p>mysql实现原子性，是通过undo.log日志实现的，mysql在执行事务操作的时候，</p>
<p>都会生成undo.log日志，将执行的sql语句记录到undo.log中，如果发生错误，导致回滚操</p>
<p>作的时候，都会将读取undo.log的语句，将执行过的语句，执行相反的操作，回滚回初始状态，</p>
<p>比如执行插入语句了，回滚时就执行删除操作、发生了更新操作，回滚时就会朝相反的更新操作</p>
<p>去执行回滚操作。</p>
<p><strong>持久性：</strong> </p>
<p>mysql持久性，也是通过日志记录形式实现的，通过redo.log日志实现的，mysql的持久化，通过缓存</p>
<p>buffer的方式来提高效率，即在查询数据时，先去查缓存buffer的数据，如果没有查询到数据，就会</p>
<p>查询磁盘IO的数据，然后将查询的数据同步到缓存buffer中；在做更新操作时，先更新缓存buffer中的数据</p>
<p>，然后再更新磁盘的操作，这些操作的目的就是通过缓存的方式，减少磁盘IO的次数，提高效率。但是这会</p>
<p>带来一个问题就是如果在操作过程中，mysql发生了宕机，那么缓存中的数据就会消失，在做更新操作时，先会</p>
<p>更新磁盘，然后更新磁盘IO，这个时候就会导致数据有丢失情况，为了解决这个问题，就需要使用redo.log，在</p>
<p>执行修改操作时，sql会先写到redo.log日志中，当事务提交时，就会将redo日志同步写到磁盘中，这样即使发生宕机情况，也会通过redo.log保证数据不丢失，达到持久性的效果。</p>
<p><strong>隔离性：</strong></p>
<p>隔离性的意思就是mysql在多个事务执行时，不能相互影响</p>
<p>这就涉及到两个方面一个是写写操作另一个就是读写操作了，</p>
<p>写写操作就是通过加上锁的方式去保证两个事务的隔离性，</p>
<p>而读写操作，就是通过mvcc来解决（包括脏读、不可重复读、幻读）</p>
<p><strong>一致性：</strong></p>
<p>事务在执行前后数据库的状态都是正常的，表现为没有违反数据完整性，</p>
<p>参照完整性和用户自定义完整性，而原子性、持久性、隔离性就是保证</p>
<p>数据库具有一致性。</p>
<h1 id="mysql的-mvcc"><a href="#mysql的-mvcc" class="headerlink" title="mysql的 mvcc"></a>mysql的 mvcc</h1><p>mvcc意思就是多版本控制，</p>
<p>同一行数据发生读写请求时，会上锁阻塞，但是mvcc用更好的方式来处理读写请求，做到在发生读写请求冲突时不用加锁。</p>
<p>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁</p>
<p><strong>什么是当前读？什么是快照读？</strong></p>
<p>当前读：</p>
<p>它读取的数据库记录，都是最新的版本，会对当前读取的数据</p>
<p>进行加锁，防止其他事务修改数据，是一种悲观锁的操作。</p>
<p>select lock in share mode (共享锁)</p>
<p>select for update （排它锁）</p>
<p>update （排它锁）</p>
<p>insert （排它锁）</p>
<p>delete （串行化）</p>
<p>串行化事务隔离级别</p>
<p>快照读：</p>
<p>快照读的实现是基于多版本并发控制， 即mvcc，既然是多版本，</p>
<p>那么快照读读到的数据不一定是当前最新的数据，有可能是之前</p>
<p>历史版本的数据。</p>
<p>mysql的innodb的隔离级别</p>
<p>1、读已提交</p>
<p>2、读未提交</p>
<p>3、可重复读</p>
<p>4、串行化</p>
<p>串行化是通过当前读实现的，是事务和事务间</p>
<p>是通过加锁的方式来读写操作、写写操作的，</p>
<p>所以执行效率很低，一般不采取这种隔离级别。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_19-22-50.png)</p>
<p>undo日志是用来记录历史数据的，比如一条记录修改了好几次，这些历史数据就会被存储到 </p>
<p>undo.log中，每条数据，不仅包含数据本生之外，还包含存储了事务ID和回滚指针，事务ID</p>
<p>是自增的，回滚指针指向上条记录的头结点。</p>
<p><strong>版本链：</strong>指的是undo.log和回滚指针连接起来的。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_21-56-52.png)</p>
<p><strong>ReadView（快照）</strong></p>
<p><strong>作用：</strong> 是一个查询语句，判断查询的是哪条记录，在undo.log中。</p>
<p><strong>注意：</strong></p>
<p><strong>参数m_ids：</strong> 指的是未提交的事务ID</p>
<p><strong>ReadView如何判断版本链中哪个版本可用？</strong></p>
<p>trx_id（当前事务ID） == creator_id（readView存储的事务ID）: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 不可以访问这个版本</p>
<p>min_trx_id  &lt;= trx_id &lt;= max_trx_id: 如果trx_id在m_ids中是不可以访问这个版本的，</p>
<p>反之可以</p>
<p><strong>抽象视图：</strong></p>
<p>已提交事务  – <strong>min_id</strong> –  未提交与已提交事务 – <strong>max_id</strong> – 未开始事务</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-37-40.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-11.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-50.png)</p>
<h1 id="B树和B-树的区别？"><a href="#B树和B-树的区别？" class="headerlink" title="B树和B+树的区别？"></a>B树和B+树的区别？</h1><p>b树也是多路查找搜索树，它的节点是存储相应的key和value值的</p>
<p>而B+树与B树的区别就是在于叶子节点和非叶子节点的关系</p>
<p>非叶子节点存储key值而叶子节点存储value值，并且叶子节点的</p>
<p>数据是以链表的方式连接的，并且是有序的。</p>
<p>B+树就是解决了B树存在的缺陷，就是会出现回旋查找的问题。</p>
<h1 id="mysql-聚簇索引和非聚簇索引"><a href="#mysql-聚簇索引和非聚簇索引" class="headerlink" title="mysql 聚簇索引和非聚簇索引"></a>mysql 聚簇索引和非聚簇索引</h1><p>聚簇索引:</p>
<p> 找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。 </p>
<p>非聚簇索引:</p>
<p> 引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">java基础面试题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 00:19:01" itemprop="dateCreated datePublished" datetime="2020-06-14T00:19:01Z">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 16:11:58" itemprop="dateModified" datetime="2021-06-08T16:11:58Z">2021-06-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h3><p><strong>抽象：</strong>抽象是将同一类对象的共同特征构造类的对象，包括数据抽象和行为抽象两个方面，并不关注细节是什么。</p>
<p><strong>继承：</strong>继承是从已有的类得到继承信息创建新类的过程。</p>
<p><strong>封装</strong>：访问控制和隐藏实现，对外提供接口，隐藏实现细节</p>
<p><strong>多态</strong>： 一个类有多种形式（父类的对象引用指向子类的对象）</p>
<p>多态分为两种一个是编译时多态一个是运行时多态。</p>
<p>编译时多态：</p>
<p>1、编译期间决定目标方法</p>
<p>2、通过overloading重载实现</p>
<p>3、方法名相同，参数不同</p>
<p>运行时多态</p>
<p>1、运行期间决定目标方法</p>
<p>2、同名同参</p>
<p>3、overrideing和继承实现</p>
<p>4、JVM决定目标方法</p>
<p>运行时多态实现机制？</p>
<p>在JVM的堆里面的方法区，存着方法表（存放方法的入口地址），</p>
<p>通过invokeVirture指令来找到对应的方法入口。</p>
<h3 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h3><p>泛型对于java语言来说只出现在编译期间，到了运行期，就会出现泛型擦除，就是原有类型全部被擦除。</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/24 18:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"t001"</span>);</span><br><span class="line">        list.add(<span class="string">"t002"</span>);</span><br><span class="line">        list.add(<span class="string">"t003"</span>);</span><br><span class="line">        list.add(<span class="string">"t004"</span>);</span><br><span class="line">        list.add(<span class="string">"t005"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass = list.getClass();</span><br><span class="line"></span><br><span class="line">        Method method = aClass.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射的方式将不同类型数据能添加到该容器中</span></span><br><span class="line">        method.invoke(list, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时会出现类型转换异常</span></span><br><span class="line">        System.out.println(list.get(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="迭代器模式？"><a href="#迭代器模式？" class="headerlink" title="迭代器模式？"></a>迭代器模式？</h4><p>1、迭代器模式是常用的设计模式，属于行为模式。</p>
<p>2、如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类</p>
<p>或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用各种遍历方式</p>
<p>，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</p>
<p>3、迭代器模式，提供一种遍历集合的统一接口，用一致的方法遍</p>
<p>历集合元素，不需要知道集合对象的底层表示，即不要暴露其内部的结构。</p>
<h3 id="为什么使用redis存储session代替session存储？（谊品生鲜一面）"><a href="#为什么使用redis存储session代替session存储？（谊品生鲜一面）" class="headerlink" title="为什么使用redis存储session代替session存储？（谊品生鲜一面）"></a>为什么使用redis存储session代替session存储？（谊品生鲜一面）</h3><p>​     当项目使用分布式时，session问题就显得比较突出了，因为有不同服务器的缘故，如果你安照一般方式存储session，那么你的session会保存在某一台服务器上，如果你的下一个请求并不是访问这台服务器，那么会发生读取不到session的情况。这种情况的解决方案有许多种，例如你可以采用session sticky的方式，但是这样会对负载均衡器造成相当大的负担，而且某台服务器挂了，会造成session丢失。或者采用session replication方式，但是如果服务器数量一多，是不是就造成了十分庞大的带宽开销，而且，如果有很多客户端同时访问服务器的话，那么每台服务器都需要保存大数量的session数据，而session数据是存储在内存中的，这样每台机器用于保存session数据占用的内存就太多了。还有一种就是采用cookie，不过这种方式是十分不可取了，先不说session数据放到客户端那边造成的安全问题，这样会造成带宽消耗，而且会强烈影响性能，而且cookie自身也有长度限制。而另外一种方式则是session 集中化处理，你可以存在数据库中，也可以采用其他分布式存储系统，这里session的储存引入了网络操作，所以可能会有数据延迟，而且当session储存设备挂了，会造成所有session丢失，不过总体来说，这种session的存储方式是十分明显的。所以这里我们采用redis，nosql的方式进行session存储。 </p>
<h1 id="B树和B-树的区别？"><a href="#B树和B-树的区别？" class="headerlink" title="B树和B+树的区别？"></a>B树和B+树的区别？</h1><p>b树也是多路查找搜索树，它的节点是存储相应的key和value值的</p>
<p>而B+树与B树的区别就是在于叶子节点和非叶子节点的关系</p>
<p>非叶子节点存储key值而叶子节点存储value值，并且叶子节点的</p>
<p>数据是以链表的方式连接的，并且是有序的。</p>
<p>B+树就是解决了B树存在的缺陷，就是会出现回旋查找的问题。</p>
<h1 id="threadLocal-原理"><a href="#threadLocal-原理" class="headerlink" title="threadLocal 原理"></a>threadLocal 原理</h1><p>threadLocal对象可以提供线程局部变量，也就是说每个线程都有一份自己的副本，</p>
<p>多个线程之间相互不干扰，通过initialValue方法来赋值，</p>
<p>我们在第一个访问get方法时，就会给线程赋值，通过initialValue方法来赋值。</p>
<p>在java8中，每个线程对应的thread对象内部都拥有一个threadLocals字段，这个</p>
<p>字段会指向一个threadLocalMap对象，这个对象关联相关的存储的数据。</p>
<h1 id="线程屏障"><a href="#线程屏障" class="headerlink" title="线程屏障"></a>线程屏障</h1><p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059361002.png" alt="1623059361002"></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059414565.png" alt="1623059414565"></p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>1、不保证原子性</p>
<p>2、可见性</p>
<p>3、指令重排</p>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_17-32-08.png)</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_17-33-01.png)</p>
<h1 id="公平锁和非公锁"><a href="#公平锁和非公锁" class="headerlink" title="公平锁和非公锁"></a>公平锁和非公锁</h1><p>公平锁：</p>
<p>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果是空的，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后按照FIFO的规则从队列中取到自己</p>
<p>非公平锁：先尝试占有锁，如果尝试失败，就采用类似公平锁的方式。（在高并发的情况下，有可能造成优先级</p>
<p>反转或者饥饿现象）</p>
<p>synchronized</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会</p>
<p>自动获取锁（锁的对象必须是同一个对象）</p>
<p>不会因为之前已经获取过还没释放而阻塞。</p>
<p>java中ReentranLock和Syncronized都是可重入锁，可重入</p>
<p>锁的一个优点就是可以避免死锁。</p>
<p><strong>Syncronized可重入原理：</strong></p>
<p>每个锁对象都拥有一个计数器和一个指向该持有该锁的线程指针。</p>
<p>当执行monitorenter时，如果目标对象的计数器为零，那么说明</p>
<p>它没有被其他线程所持有，java虚拟机会将该锁对象的持有线程设置</p>
<p>为当前线程，并且将其计数器加1。</p>
<p>在目标对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，</p>
<p>那么java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，java虚拟机则需将锁对象计数器减1.计数器为0代表该</p>
<p>锁已经释放。</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>类似于线程等待唤醒机制（wait/notify）</p>
<p>是用来创建锁和其他同步类的基本线程阻塞原语。</p>
<p>LockSupport中park（）和unpark（）的作用分别是</p>
<p>阻塞线程和解除阻塞线程。</p>
<p>阻塞线程的工具类，可以让线程在任意位置阻塞，阻塞之后也有唤醒的方法，</p>
<p>LockSupprt调用的是unsafe中的native代码。</p>
<p>LockSupprt和每个使用它的线程都有一个许可（permit）。</p>
<p>permit相当于1,0的开关，默认是0，</p>
<p>调用一次unpark就加1变成1，</p>
<p>调用park会消费permit，就是将0变为1，</p>
<p>如果再次调用park就会被阻塞</p>
<p>线程阻塞需要消耗permit，这个凭证最多只有1个。</p>
<p><strong>为什么可以先唤醒线程后，阻塞线程？</strong></p>
<p>因为unpark获得一个凭证，之后再调用park方法，就可以消费，所以</p>
<p>不会阻塞。</p>
<p><strong>为什么唤醒两次之后阻塞两次，但最终结果还会阻塞线程？</strong></p>
<p>因为凭证的数量最多为1，连续调用两次unparkhe调用一次unpark效果</p>
<p>一样，只会增加一个凭证，而调用两次park却要消费两个凭证，证不够，</p>
<p>不能放行。</p>
<p><strong>三种实现等待和唤醒机制的方式？</strong></p>
<p>1、使用Object类中的wait和notify方法实现线程等待和唤醒</p>
<p><strong>注意点：</strong>就是必须要synchronized代码块联合使用</p>
<p>，还有必须先wait再notify，否则会导致线程一直处于阻塞状态。</p>
<p>2、Condition接口中await后signal方法实现线程的等待和唤醒机制</p>
<p><strong>注意点：</strong>就是必须要synchronized代码块联合使用</p>
<p>，还有必须先wait再notify，否则会导致线程一直处于阻塞状态。</p>
<p>3、使用LcokSupport类中的park等待和unpark唤醒</p>
<h1 id="AQS（抽象队列同步器）原理："><a href="#AQS（抽象队列同步器）原理：" class="headerlink" title="AQS（抽象队列同步器）原理："></a>AQS（抽象队列同步器）原理：</h1><p>用来构建锁或者其他同步组件的重量级基础框架及整个JUC体系的基石，通过</p>
<p>内置的FIFP队列来完成资源获取线程的排队工作，并通过一个int类型的变量来</p>
<p>表示锁的状态。</p>
<p>抢到资源的线程直接处理业务逻辑，抢不到资源的必然涉及一种排队等待机制，抢占资源失败的线程继续</p>
<p>去等待，但等待线程任然保留获取锁流程任在继续。</p>
<p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列实现的，</p>
<p>将占时获取不到锁的线程加到队列中，这个队列就是AQS的抽象表现，它将请求共享资源的线程封装成队列</p>
<p>Node，通过CAS、自旋以及LockSupport.park()的方式维护state变量的撞他，使并发达到同步控制的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 共享 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** 独占 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 线程被取消 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 后继线程需要被唤醒 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 等待condition唤醒 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        共享式同步状态获取将无条件地传播下去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        初始为0，状态是上面的几种</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        前置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        Node节点保存的线程对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_16-09-02.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_16-01-58.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_15-39-41.png)</p>
<h3 id="用过线程池吗？有哪些线程池？有哪些参数？-（谊品生鲜一面）"><a href="#用过线程池吗？有哪些线程池？有哪些参数？-（谊品生鲜一面）" class="headerlink" title="用过线程池吗？有哪些线程池？有哪些参数？ （谊品生鲜一面）"></a>用过线程池吗？有哪些线程池？有哪些参数？ （谊品生鲜一面）</h3><p><strong>线程池的类型有哪些？</strong></p>
<p> <strong>1、newCachedThreadPool</strong> </p>
<p>创建一个可缓存线程池</p>
<p> <strong>2、newFixedThreadPool</strong> </p>
<p>指定工作线程的线程池</p>
<p> <strong>3、newSingleThreadExecutor</strong> </p>
<p>单线程线程池，只创建工作线程来执行任务</p>
<p> <strong>4、newScheduleThreadPool</strong> </p>
<p>定长的线程池</p>
<p> <strong>5、newSingleThreadScheduledExecutor</strong> </p>
<p> 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。 </p>
<p><strong>使用线程池的优势？</strong></p>
<p>1、降低资源消耗（如线程的上下文切换时，就会创建线程或者销毁线程）</p>
<p>2、提高响应速度，当任务到达时，任务无需等待线程的创建就会立刻执行</p>
<p>3、提高线程管理性</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-05-27_14-29-18.png)</p>
<p><strong><em>线程池执行流程</em></strong></p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_13-26-19.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize 线程池的基本大小</span><br><span class="line">    </span><br><span class="line">runnableTaskQueue: 用于保存等待执行的任务阻塞队列</span><br><span class="line">     ArrayBlockingQueue: 一个基于数组的阻塞队列（先进先出）</span><br><span class="line">     LinkedBlockingQueue: 一个基于链表结构的阻塞队列，吞吐量高于基于数组的阻塞队列</span><br><span class="line">     synchronousQueue: 一个不存储元素的阻塞队列。每个插入操作都必须等到另一个线程调用移除</span><br><span class="line">         操作，否则插入操作一直处于阻塞状态，吞吐量高于基于链表的阻塞队列</span><br><span class="line">     priorityBlockingQueue: 一个具有优先级的无线循环阻塞队列</span><br><span class="line">         </span><br><span class="line">maximumPoolSize：线程池最大数量，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数</span><br><span class="line">         小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果适用了无界阻塞队列</span><br><span class="line">         这个参数的设置就是无效的。</span><br><span class="line">ThreadFactory：用于创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置名称。</span><br><span class="line">         </span><br><span class="line">RejectedExecutionHandler: 当队列和线程池都满了，说明线程池处于饱和状态，那么就必须采取一种策略</span><br><span class="line">    处理提交的新任务。这个策略默认情况下AbortPolicy，表示无法处理新任务时抛出异常。</span><br><span class="line">    </span><br><span class="line">    AbortPolicy： 直接抛出异常</span><br><span class="line">    callerRunsPolicy：只用调用者所在线程来运行任务</span><br><span class="line">    DiscardOldestPolicy: 丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">    DiscardPolicy：不处理，丢弃掉。</span><br><span class="line">        </span><br><span class="line">    自定义一个 RejectedExecutionHandler 接口自定义处理策略，如记录日志</span><br><span class="line">    或持久化存储不能处理的任务。</span><br><span class="line">        </span><br><span class="line">keepAliveTime：线程池的工作线程空闲后，保持存活的时间。所以如果</span><br><span class="line">        任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的</span><br><span class="line">        利用率。</span><br><span class="line">        </span><br><span class="line">TimeUnit：线程活动保持时间的单位</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>线程池拒绝策略</strong></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059719526.png" alt="1623059719526"></p>
<p><strong>合理配置线程池？</strong></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059655560.png" alt="1623059655560"></p>
<p>1、任务性质</p>
<p>2、任务优先级</p>
<p>3、任务执行长短</p>
<p>4、任务是否具有依赖性</p>
<p>1、性质不同的任务可以用不同规模的线程池分开处理</p>
<p>2、如果根据优先级去考虑的话，可能要使用无界阻塞队列</p>
<p>因为他会根据任务优先级的高低来优先处理任务</p>
<p>3、执行时间不同的任务可以交给不同规模的线程池来处理，或者使用</p>
<p>优先级队列处理时间短的任务。</p>
<p>4、如果任务依赖于数据库，因为线程提交sql后需要等待数据库返回</p>
<p>结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置的</p>
<p>越大，这样才能更好地利用cpu。</p>
<p>5、建议使用有界队列</p>
<h3 id="Java包装器类的作用"><a href="#Java包装器类的作用" class="headerlink" title="Java包装器类的作用"></a>Java包装器类的作用</h3><p>1 类里有相应方法方便用户调用</p>
<p>2 可以用类的对象和null进行比较，避免java.lang.nullPointException</p>
<h4 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a><strong>springboot自动配置原理</strong></h4><p>在springboot 启动工程类中，注解为@SpringBootApplication的实现类中，里面有一个注解@EnableAutoConfiguation的实现类中，它将AutoConfigurationImportSelector这个类通过注解@Import加载到IOC容器中，这个类实现了DeferredImportSelector, BeanClassLoaderAware这两个接口，它会将它EnableAutoConfiguration.class加载进来，会将META-INF/spring.factories这个文件中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，value为springboot的默认的配置类加载到IOC容器中，但是每个配置类里面都会有一些加载条件，如果不满足就无法将配置类加载到IOC容器中。</p>
<h4 id="java反射技术"><a href="#java反射技术" class="headerlink" title="java反射技术"></a>java反射技术</h4><p>反射技术是动态语言的关键，反射机制允许程序在执行期借助于Reflection API，取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象就包含了完整的类结构信息，我们可以通过这个类的结构。</p>
<p>正常方式获取对象的方法和属性： 创建对象实例  获取对象的信息</p>
<p>反射方式： 实例化对象  — getClass()方法   — 得到完整的包类名称</p>
<h4 id="java注解原理"><a href="#java注解原理" class="headerlink" title="java注解原理"></a>java注解原理</h4><h4 id="springboot启动原理"><a href="#springboot启动原理" class="headerlink" title="springboot启动原理"></a>springboot启动原理</h4><h1 id="redis-底层数据结构之跳跃表"><a href="#redis-底层数据结构之跳跃表" class="headerlink" title="redis 底层数据结构之跳跃表"></a>redis 底层数据结构之跳跃表</h1><p>跳跃表（<a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener external nofollow noreferrer">skiplist</a>）是一种随机化的数据， 由 William Pugh 在论文<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noopener external nofollow noreferrer">《Skip lists: a probabilistic alternative to balanced trees》</a>中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p>
<p>以下是个典型的跳跃表例子（图片来自<a href="http://en.wikipedia.org/wiki/File:Skip_list.svg" target="_blank" rel="noopener external nofollow noreferrer">维基百科</a>）：</p>
<p><a href="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png" target="_blank" rel="noopener external nofollow noreferrer"><img src="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png" alt="../_images/skiplist.png"></a></p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li>
</ul>
<p>因为跳跃表的定义可以在任何一本算法或数据结构的书中找到， 所以本章不介绍跳跃表的具体实现方式或者具体的算法， 而只介绍跳跃表在 Redis 的应用、核心数据结构和 API 。</p>
<h1 id="arraryList扩容"><a href="#arraryList扩容" class="headerlink" title="arraryList扩容"></a>arraryList扩容</h1><p>每次插入时，都会判断容器的容量是否能存放完待插入的数据，如果不能则，</p>
<p>将容器扩容为原来的1.5倍</p>
<h1 id="hashMap-原理"><a href="#hashMap-原理" class="headerlink" title="hashMap 原理"></a>hashMap 原理</h1><p>（扩容机制、负载因子、红黑树、散列表等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16  散列表中数组的初始容量大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 散列表最大容量2的31次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 链表转换为红黑树的阀值（当链表的大小为8时，转为红黑树）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">// 红黑树降级为链表的阀值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; </span><br><span class="line"><span class="comment">// 树化的另一个参数，</span></span><br><span class="line"><span class="comment">// 当哈希表中所有元素超过64时，才会允许将链表结构转换为红黑树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">// hash值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="comment">// key值</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="comment">// value值</span></span><br><span class="line">        V value;</span><br><span class="line">       <span class="comment">// 下一个节点的值</span></span><br><span class="line">        Node&lt;K,V&gt; next;   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashMap的属性介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表， 什么时候初始化？</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前hash表中元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前哈希表结构修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阀值， 当哈希表中的元素超过阀值时，触发扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阀值、负载因子、散列表容量关系？</span></span><br><span class="line"><span class="comment">// threshold = loadFactor * capacity</span></span><br><span class="line"><span class="comment">// 例子： threshold = 16 * 0.75f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashMap 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化容量不能为小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 初始化容器的值不能大于最大容量大小</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">// 负载因子不能为小于等于0，并且是float类型的数字</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 扩容阀值赋值</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">扩容阀值赋值</span></span><br><span class="line"><span class="comment">返回一个大于等于当前cap的一个数字，</span></span><br><span class="line"><span class="comment">且必须是2的次方数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种算法就是保证返回出来的值是2的次方数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">扰动函数</span></span><br><span class="line"><span class="comment">让key的hash值的高16位也参与路由运算。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tab 引用当前hash表</span></span><br><span class="line">        <span class="comment">// p 表示当前散列表的元素</span></span><br><span class="line">        <span class="comment">// n 表示散列表的长度</span></span><br><span class="line">        <span class="comment">// i 路由寻址结果</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hashMap会延迟初始化，只有put的时候，才会开辟内存，存储数据，这样不会浪费内存</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 寻址找到的桶为为null，这个时候就可以将value值直接存放到该桶位中</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// e node临时元素</span></span><br><span class="line">            <span class="comment">// k 表示临时的一个key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="mysql-ACID执行原理"><a href="#mysql-ACID执行原理" class="headerlink" title="mysql ACID执行原理"></a><strong>mysql ACID执行原理</strong></h1><p>mysql 的acid指的是 原子性、持久性、隔离性、一致性</p>
<p><strong>原子性：</strong> </p>
<p>mysql实现原子性，是通过undo.log日志实现的，mysql在执行事务操作的时候，</p>
<p>都会生成undo.log日志，将执行的sql语句记录到undo.log中，如果发生错误，导致回滚操</p>
<p>作的时候，都会将读取undo.log的语句，将执行过的语句，执行相反的操作，回滚回初始状态，</p>
<p>比如执行插入语句了，回滚时就执行删除操作、发生了更新操作，回滚时就会朝相反的更新操作</p>
<p>去执行回滚操作。</p>
<p><strong>持久性：</strong> </p>
<p>mysql持久性，也是通过日志记录形式实现的，通过redo.log日志实现的，mysql的持久化，通过缓存</p>
<p>buffer的方式来提高效率，即在查询数据时，先去查缓存buffer的数据，如果没有查询到数据，就会</p>
<p>查询磁盘IO的数据，然后将查询的数据同步到缓存buffer中；在做更新操作时，先更新缓存buffer中的数据</p>
<p>，然后再更新磁盘的操作，这些操作的目的就是通过缓存的方式，减少磁盘IO的次数，提高效率。但是这会</p>
<p>带来一个问题就是如果在操作过程中，mysql发生了宕机，那么缓存中的数据就会消失，在做更新操作时，先会</p>
<p>更新磁盘，然后更新磁盘IO，这个时候就会导致数据有丢失情况，为了解决这个问题，就需要使用redo.log，在</p>
<p>执行修改操作时，sql会先写到redo.log日志中，当事务提交时，就会将redo日志同步写到磁盘中，这样即使发生宕机情况，也会通过redo.log保证数据不丢失，达到持久性的效果。</p>
<p><strong>隔离性：</strong></p>
<p>隔离性的意思就是mysql在多个事务执行时，不能相互影响</p>
<p>这就涉及到两个方面一个是写写操作另一个就是读写操作了，</p>
<p>写写操作就是通过加上锁的方式去保证两个事务的隔离性，</p>
<p>而读写操作，就是通过mvcc来解决（包括脏读、不可重复读、幻读）</p>
<p><strong>一致性：</strong></p>
<p>事务在执行前后数据库的状态都是正常的，表现为没有违反数据完整性，</p>
<p>参照完整性和用户自定义完整性，而原子性、持久性、隔离性就是保证</p>
<p>数据库具有一致性。</p>
<h1 id="mysql的-mvcc"><a href="#mysql的-mvcc" class="headerlink" title="mysql的 mvcc"></a>mysql的 mvcc</h1><p>mvcc意思就是多版本控制，</p>
<p>同一行数据发生读写请求时，会上锁阻塞，但是mvcc用更好的方式来处理读写请求，做到在发生读写请求冲突时不用加锁。</p>
<p>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁</p>
<p><strong>什么是当前读？什么是快照读？</strong></p>
<p>当前读：</p>
<p>它读取的数据库记录，都是最新的版本，会对当前读取的数据</p>
<p>进行加锁，防止其他事务修改数据，是一种悲观锁的操作。</p>
<p>select lock in share mode (共享锁)</p>
<p>select for update （排它锁）</p>
<p>update （排它锁）</p>
<p>insert （排它锁）</p>
<p>delete （串行化）</p>
<p>串行化事务隔离级别</p>
<p>快照读：</p>
<p>快照读的实现是基于多版本并发控制， 即mvcc，既然是多版本，</p>
<p>那么快照读读到的数据不一定是当前最新的数据，有可能是之前</p>
<p>历史版本的数据。</p>
<p>mysql的innodb的隔离级别</p>
<p>1、读已提交</p>
<p>2、读未提交</p>
<p>3、可重复读</p>
<p>4、串行化</p>
<p>串行化是通过当前读实现的，是事务和事务间</p>
<p>是通过加锁的方式来读写操作、写写操作的，</p>
<p>所以执行效率很低，一般不采取这种隔离级别。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_19-22-50.png)</p>
<p>undo日志是用来记录历史数据的，比如一条记录修改了好几次，这些历史数据就会被存储到 </p>
<p>undo.log中，每条数据，不仅包含数据本生之外，还包含存储了事务ID和回滚指针，事务ID</p>
<p>是自增的，回滚指针指向上条记录的头结点。</p>
<p><strong>版本链：</strong>指的是undo.log和回滚指针连接起来的。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_21-56-52.png)</p>
<p><strong>ReadView（快照）</strong></p>
<p><strong>作用：</strong> 是一个查询语句，判断查询的是哪条记录，在undo.log中。</p>
<p><strong>注意：</strong></p>
<p><strong>参数m_ids：</strong> 指的是未提交的事务ID</p>
<p><strong>ReadView如何判断版本链中哪个版本可用？</strong></p>
<p>trx_id（当前事务ID） == creator_id（readView存储的事务ID）: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 不可以访问这个版本</p>
<p>min_trx_id  &lt;= trx_id &lt;= max_trx_id: 如果trx_id在m_ids中是不可以访问这个版本的，</p>
<p>反之可以</p>
<p><strong>抽象视图：</strong></p>
<p>已提交事务  – <strong>min_id</strong> –  未提交与已提交事务 – <strong>max_id</strong> – 未开始事务</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-37-40.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-11.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-50.png)</p>
<h1 id="dubbo的负载均衡策略"><a href="#dubbo的负载均衡策略" class="headerlink" title="dubbo的负载均衡策略"></a>dubbo的负载均衡策略</h1><p>1、random</p>
<p>随机算法，是dubbo默认的负载均衡策略，在多态机器上的服务随机</p>
<p>取一台服务进行调用，如果各个机器性能没有太大差异的情况下，可以采取这种策略。</p>
<p>但是这种策略可能导致服务堆积问题。</p>
<p>2、roundrobin</p>
<p>轮询算法，多态机器上的服务按照请求顺序依次轮着调用，保证一定得公平性，实际使用</p>
<p>的时候可以按照设定好的权重依次进行调度，这样避免性能差的服务器出现大面积的服务调用超时情况。</p>
<p>3、leastactive</p>
<p>最少活跃调度算法，即被调度次数越少，其优先级就越高，被调度到的几率就越高。</p>
<p>4、consistenthash</p>
<p>一致性hash算法，对于相同参数的请求，其会被路由到相同的提供者，</p>
<p>可以根据请求的IP地址进行hash，或者请求参数，或者某个业务参数等</p>
<p>进行hash取值，一致性hash在Nginx集群做网关配置时也有此用法。</p>
<h1 id="Spring传播范围"><a href="#Spring传播范围" class="headerlink" title="Spring传播范围"></a>Spring传播范围</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. PROPAGATION_REQUIRED  支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </span><br><span class="line"><span class="number">2</span>. PROPAGATION_SUPPORTS  支持当前事务，如果当前没有事务，就以非事务方式执行。 </span><br><span class="line"><span class="number">3</span>. PROPAGATION_MANDATORY  支持当前事务，如果当前没有事务，就抛出异常。 </span><br><span class="line"><span class="number">4</span>. PROPAGATION_REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。 </span><br><span class="line"><span class="number">5</span>. PROPAGATION_NOT_SUPPORTED  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </span><br><span class="line"><span class="number">6</span>. PROPAGATION_NEVER  以非事务方式执行，如果当前存在事务，则抛出异常。 </span><br><span class="line"><span class="number">7</span>. PROPAGATION_NEST   新起一个事务，但是内嵌并与已存在的外部事务，如果外部事务回滚，则此事务也会回滚</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">java并发学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-11 17:12:37" itemprop="dateCreated datePublished" datetime="2020-06-11T17:12:37Z">2020-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-12 18:39:00" itemprop="dateModified" datetime="2020-06-12T18:39:00Z">2020-06-12</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><p><strong>进程</strong></p>
<p>是操作系统分配资源的最小单位，系统在运行时，会为每个进程分配不同的内部区域</p>
<p><strong>线程</strong></p>
<p>是操作系统调度资源的最小单位</p>
<p><strong>并行</strong></p>
<p>多个cpu执行多个任务</p>
<p><strong>并发</strong></p>
<p>一个cpu（时间片算法）同时执行多个任务。</p>
<p><strong>多线程的优势</strong>：<br>1、提高应用程序的响应速度。</p>
<p>2、提高cpu的利用率</p>
<p>3、改善程序结构。</p>
<p><strong>创建线程的方式</strong></p>
<p>java5之前</p>
<p>1、继承thread</p>
<p>2、实现runnable接口</p>
<p>java5后</p>
<p>1、实现callable接口</p>
<p>2、创建线程池方式（ExecutorService和Executors)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/12 22:48</span></span><br><span class="line"><span class="comment"> * 1、继承Thread类</span></span><br><span class="line"><span class="comment"> * 2、实现Runnable接口，实现run方法</span></span><br><span class="line"><span class="comment"> * 3、实现callable接口</span></span><br><span class="line"><span class="comment"> * 4、使用线程池的方式创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方式1： 继承Thread类，实现run方法</span></span><br><span class="line"><span class="comment">//        ThreadMethod01 threadMethod01 = new ThreadMethod01();</span></span><br><span class="line"><span class="comment">//        threadMethod01.start();</span></span><br><span class="line">        <span class="comment">// 方式2： 实现Runnable接口，实现run方法</span></span><br><span class="line"><span class="comment">//        ThreadMethod02  threadMethod02 = new ThreadMethod02();</span></span><br><span class="line"><span class="comment">//        threadMethod02.run();</span></span><br><span class="line">        <span class="comment">// 方式3：实现callable接口</span></span><br><span class="line"><span class="comment">//        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new ThreadMethod03());</span></span><br><span class="line"><span class="comment">//        new Thread(futureTask).start();</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Integer value = futureTask.get();</span></span><br><span class="line"><span class="comment">//            System.out.println(value);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">// 方式4： 使用线程池的方式创建线程</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Thread04());</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Thread04());</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Thread04());</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread04</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod03</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod02</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            Thread.currentThread().setName(<span class="string">"thread"</span> + i);</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"---"</span> +Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            currentThread().setName(<span class="string">"thread"</span> + i);</span><br><span class="line">            System.out.println(currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>线程池</strong></p>
<p>java的线程池是通过Executor框架实现的，该框架使用到了Executor.Executors,ExecutorService,ThreadPoolExecutor</p>
<p><img src="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/sp03.png" alt></p>
<p>好处：<br>1、降低资源的消耗，避免了重复创建的线程，降低线程创建和销毁资源的消耗</p>
<p>2、提高响应速度，当任务到达时，无需等待线程创建的时间</p>
<p>3、提高线程的可管理性。</p>
<p><strong>线程池的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​     java中可以通过修改setPriority(int)来修改线程优先级，但是这并不起作用，因为操作系统可以不用理会java线程对于优先级的限制。</p>
<p><strong>线程的生命周期</strong></p>
<p>java线程在运行的生命周期有6中运行状态。</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>初始状态，线程被构建但是还没有调用start</td>
</tr>
<tr>
<td>runnable</td>
<td>运行状态，java线程将操作系统中的就绪状态和运行状态统称为运行中</td>
</tr>
<tr>
<td>blocked</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>waiting</td>
<td>等待状态，表示线程进入等待状态，当前线程需要等待其他线程做一些特定的动作（中断或者通知）</td>
</tr>
<tr>
<td>time_waiting</td>
<td>超时等待状态，该状态不同于waiting，它是可以指定的时间内自行返回的</td>
</tr>
<tr>
<td>terminated</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p><strong>java线程状态变迁</strong></p>
<p><img src="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/sp01.png" alt></p>
<p><img src="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/sp02.png" alt></p>
<p>并发编程的挑战：上下文的切换、死锁问题、以及软件和硬件资源的不足</p>
<p><strong>上下文切换</strong>：我们平常说的单核cpu也可以实现多线程，cpu通过给每个线程分配时间片来实现这个机制。时间片是cpu分配给每个线程，所以时间非常的短，所以所以每个线程都在不停的切换，让人们感到像是多个线程同时执行一样。所以说上下文的切换也在消耗资源，也是并发编程的挑战之一。</p>
<p>如何避免上下文的切换：</p>
<p>方法：有无锁的并发编程、CAS算法、使用最少的线程和协程。</p>
<p>有无锁的并发编程：多线程竞争锁时，就会引起上下文切换，所以多线程处理数据时，可以使用一些方法避免使用锁，如将数据的ID按照hash算法取模分段，不同的线程处理不同段的数据。</p>
<p>CAS算法：使用CAS算法来更新数据，而不需要加锁。</p>
<p>使用少的线程：根据不同的情况尽可能少的使用线程。</p>
<p>协程：在单线程里实现多任务调度，并在单线程里维持多个任务间内切换。</p>
<p><strong>死锁</strong></p>
<p>死锁：两个线程都在互相等待对方的资源，导致程序崩溃。</p>
<p>解决死锁方法：<br>1、避免一个线程同时获得多个锁</p>
<p>2、避免一个线程在锁同时占用多个资源，尽量保证每个锁只占用一个资源。</p>
<p>3、尝试使用定时锁，使用lock.tryLock(timetout)来替代适用内部锁机制。</p>
<p>4、对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p>
<p>​    </p>
<p><strong>资源限制</strong></p>
<h2 id="java并发机制的底层原理"><a href="#java并发机制的底层原理" class="headerlink" title="java并发机制的底层原理"></a>java并发机制的底层原理</h2><p>​      java在编译后会变成字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转换为汇编指令在cpu执行，java中所使用的并发机制依赖于JVM的实现和cpu的指令。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volidate是轻量级的synchronized，它的特点就是可见性、禁止指令重排、不具有原子性。</p>
<p>不可见性：当两个线程，同时操作一组数据，两组数据都从主内存中拷贝副本到线程私有的工作线程，当一个线程将其修改，另一个线程并不知道有个线程将数据修改，导致数据的安全性没有了保证。</p>
<p>指令重排：java在编译多线程程序时，会将java程序编译成字节码去加载到JVM中，但是每个字节码并不一定按照程序的顺序执行，而是按照JVM加载顺序执行，这就时指令重排，而volatile关键字就会保证指令不重排，使得数据安全性得到了保证。</p>
<p>原子性：一个操作或者多个操作要么全部执行、要么全部失败。</p>
<p><strong>synchronized</strong></p>
<p>​     很多人称它为重度锁，在java6后就进行了一定优化，引入了偏向锁和轻量级锁以及对锁的存储结构升级，使得synchronized不再那么重了。</p>
<p>synchronized实现同步的基础，java中每个对象都可以作为锁。</p>
<p>具体表现：</p>
<p>1、对于普通方法，锁是当前实例对象。</p>
<p>2、对于静态方法，锁是当前Class对象。</p>
<p>3、对于同步方法块，锁是synchronized括号里的对象。</p>
<p>当一个线程试图访问同步代码块时必须先得到锁，正常退出或者抛出异常时，必须释放锁。</p>
<p>synchronized实现原理：</p>
<p>​     对于synchronized在同步代码块中，将monitor命令解析的字节码是monitorenter和monitorexit指令放在要同步程序的前后，任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/redis%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/11/redis%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">redis学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 17:26:43" itemprop="dateCreated datePublished" datetime="2020-06-10T17:26:43Z">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-11 09:12:59" itemprop="dateModified" datetime="2020-06-11T09:12:59Z">2020-06-11</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/11/redis%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/11/redis%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis学习"><a href="#redis学习" class="headerlink" title="redis学习"></a>redis学习</h1><p> redis默认有16个库。</p>
<p>1、<strong>select index</strong></p>
<p>切换存储库</p>
<h2 id="redis-数据类型介绍"><a href="#redis-数据类型介绍" class="headerlink" title="redis 数据类型介绍"></a>redis 数据类型介绍</h2><p>  redis有五种数据类型：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset(sorted set 有序集合)</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>key — value</p>
<p>String是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string <u>可以包含任何数据</u>。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 *<u>512MB。</u>*</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1、<strong>SET key value</strong> </p>
<p>添加string类型k-v键值对</p>
<p>2、<strong>GET key</strong></p>
<p>获取指定键的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set token 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get token</span><br><span class="line">"123456"</span><br></pre></td></tr></table></figure>

<p>3、<strong>MSET key1 value1 key2 value2 […]</strong></p>
<p>设置多个键和值</p>
<p>4、<strong>MGET key1[key2…]</strong></p>
<p>得到所有给定键的值（Multi GET）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; MSET token1 111 token2 222</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; MGET token1 token2</span><br><span class="line">1) "111"</span><br><span class="line">2) "222"</span><br></pre></td></tr></table></figure>

<p>5、<strong>SETNX key value</strong></p>
<p>设置键的值，只有当该键不存在</p>
<p>6、<strong>MSETNX key value [key value …]</strong> </p>
<p>设置多个键多个值，只有在当没有按键的存在时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; SETNX token1 1333</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; MSETNX token1 23 token9 1233</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>7、<strong>INCR key</strong></p>
<p>增加键的值整数值一次（+1）</p>
<p>8、<strong>INCRBY key increment</strong></p>
<p>由给定的数量递增键的整数值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379[1]&gt; INCR  12</span><br><span class="line">(integer) 14</span><br><span class="line">127.0.0.1:6379[1]&gt; INCRBY 12 10</span><br><span class="line">(integer) 24</span><br></pre></td></tr></table></figure>

<p>9、DECR key</p>
<p>递减键一次的整数值</p>
<p>10、DECRBY key decrement</p>
<p>由给定数目递减键的整数值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; MGET 12</span><br><span class="line">1) "24"</span><br><span class="line">127.0.0.1:6379[1]&gt; INCR 12</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379[1]&gt; DECR 12</span><br><span class="line">(integer) 24</span><br><span class="line">127.0.0.1:6379[1]&gt; DECRBY 12 5</span><br><span class="line">(integer) 19</span><br></pre></td></tr></table></figure>

<p>11、STRLEN key</p>
<p>得到存储在键的值的长度</p>
<p>12、GETRANGE key start end</p>
<p>截取指定key对应的值</p>
<p>13、APPEND key value</p>
<p>截取指定key对应的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set one hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; STRLEN one</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379[1]&gt; GETRANGE one 0 3</span><br><span class="line">"hell"</span><br><span class="line">127.0.0.1:6379[1]&gt; APPEND one world</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379[1]&gt; get one</span><br><span class="line">"helloworld"</span><br></pre></td></tr></table></figure>



<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类，即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：</p>
<ul>
<li>获取字符串长度</li>
<li>往字符串append内容</li>
<li>设置和获取字符串的某一段内容</li>
<li>设置及获取字符串的某一位（bit）</li>
<li>批量设置一系列字符串的内容</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>key — key-&gt; value</p>
<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p>1、<strong>HSET key field value</strong></p>
<p>用于存储一组hash值</p>
<p>heset web one one</p>
<p>2、<strong>HGET key field</strong> </p>
<p>用于查看一组数据的hash值的value值</p>
<p>hget web one </p>
<p>3<strong>、HEXISTS key field</strong> </p>
<p>查看是否这组hash值</p>
<p>HEXISTS web one</p>
<p>4、<strong>HDEL key field1 [field2]</strong> </p>
<p>删除一个或多个hash值</p>
<p>HDEL wbe three four</p>
<p>5、 <strong>HMGET key field1 [field2]</strong></p>
<p>获取所有给定字段值</p>
<p>HGET web three</p>
<p>6、<strong>HMSET key field1 value1 [field2 value2 ]</strong></p>
<p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p>
<p>HMGET web three four</p>
<p>7、<strong>HMSET key field1 value1 [field2 value2 ]</strong></p>
<p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p>
<p>HMSET web one one two two three three four four five five six six</p>
<p>8、<strong>HKEYS key</strong></p>
<p>获取所有哈希表中的字段</p>
<p> HKEYS web</p>
<p>9、<strong>HVALS key</strong></p>
<p>获取哈希表中所有值</p>
<p>HVALS web</p>
<p>10、<strong>HINCRBY key field increment</strong></p>
<p>为哈希表 key 中的指定字段的整数值加上增量 increment 。返回增加之后的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET pp one 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget pp one</span><br><span class="line">"111"</span><br><span class="line">127.0.0.1:6379&gt; hincrby pp one 222</span><br><span class="line">(integer) 333</span><br><span class="line">127.0.0.1:6379&gt; hget pp one</span><br><span class="line">"333"</span><br></pre></td></tr></table></figure>

<p>11、<strong>HINCRBYFLOAT key field increment</strong></p>
<p>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset pp two 11.22</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget pp two</span><br><span class="line">"11.22"</span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT pp two 22.33</span><br><span class="line">"33.549999999999997"</span><br></pre></td></tr></table></figure>

<p>12、<strong>HSETNX key field value</strong></p>
<p>只有在字段 field 不存在时，设置哈希表字段的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL web</span><br><span class="line"> 1) "two"</span><br><span class="line"> 2) "two"</span><br><span class="line"> 3) "one"</span><br><span class="line"> 4) "one"</span><br><span class="line"> 5) "three"</span><br><span class="line"> 6) "three"</span><br><span class="line"> 7) "four"</span><br><span class="line"> 8) "four"</span><br><span class="line"> 9) "five"</span><br><span class="line">10) "five"</span><br><span class="line">11) "six"</span><br><span class="line">12) "six"</span><br><span class="line">127.0.0.1:6379&gt;  hsetnx web one 122</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HGETALL web</span><br><span class="line"> 1) "two"</span><br><span class="line"> 2) "two"</span><br><span class="line"> 3) "one"</span><br><span class="line"> 4) "one"</span><br><span class="line"> 5) "three"</span><br><span class="line"> 6) "three"</span><br><span class="line"> 7) "four"</span><br><span class="line"> 8) "four"</span><br><span class="line"> 9) "five"</span><br><span class="line">10) "five"</span><br><span class="line">11) "six"</span><br><span class="line">12) "six"</span><br><span class="line">127.0.0.1:6379&gt;  hsetnx web ten 122</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL web</span><br><span class="line"> 1) "two"</span><br><span class="line"> 2) "two"</span><br><span class="line"> 3) "one"</span><br><span class="line"> 4) "one"</span><br><span class="line"> 5) "three"</span><br><span class="line"> 6) "three"</span><br><span class="line"> 7) "four"</span><br><span class="line"> 8) "four"</span><br><span class="line"> 9) "five"</span><br><span class="line">10) "five"</span><br><span class="line">11) "six"</span><br><span class="line">12) "six"</span><br><span class="line">13) "ten"</span><br><span class="line">14) "122"</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>例子: </p>
<p>存储用户信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset 160310328sunli id 1 stuId 160310328 name sunli sex M phone 13965540902 email 3398536845@qq.com</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGETALL  160310328sunli</span><br><span class="line"> 1) "id"</span><br><span class="line"> 2) "1"</span><br><span class="line"> 3) "stuId"</span><br><span class="line"> 4) "160310328"</span><br><span class="line"> 5) "name"</span><br><span class="line"> 6) "sunli"</span><br><span class="line"> 7) "sex"</span><br><span class="line"> 8) "M"</span><br><span class="line"> 9) "phone"</span><br><span class="line">10) "13965540902"</span><br><span class="line">11) "email"</span><br><span class="line">12) "3398536845@qq.com"</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/11/redis%E5%AD%A6%E4%B9%A0/sp01.png" alt></p>
<h2 id="reids-的持久化机制"><a href="#reids-的持久化机制" class="headerlink" title="reids 的持久化机制"></a>reids 的持久化机制</h2><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>​    在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的快照Snapshot,它恢复时是将快照文件直接读取到内存里。</p>
<p>   redis会单独创建一个子线程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效。RDB的缺点就是最后一次持久化后的数据可能会丢失。</p>
<p>Fork的作用是复制一个与当前一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
<p>RDB是整个内存的压缩过的快照，RDB的数据结构，可以配置复合的快照触发条件。</p>
<p>默认</p>
<p>一分钟内改一万次，</p>
<p>或五分钟内改10次</p>
<p>或15分钟改一次</p>
<p>就备份当前数据存储在dump.rdb中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>​     如果想禁用RDB持久化策略，只要不设置任何save指令，或者save传入一个空字符串参数也可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果配置NO，表示不在乎数据不一致或者有其他的手段发现和控制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure>

<p>rdbcompression 对于存储到磁盘中快照，可以设置是否进行压缩存储，如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗cpu来进行压缩的话，可以关闭此功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that&#39;s set to &#39;yes&#39; as it&#39;s almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to &#39;no&#39; but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>

<p>rdbchecksum 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<h4 id="RDB优势"><a href="#RDB优势" class="headerlink" title="RDB优势"></a>RDB优势</h4><p>1、适合大规模的数据恢复</p>
<p>2、对数据完整性和一致性要求不高</p>
<h4 id="RDB劣势"><a href="#RDB劣势" class="headerlink" title="RDB劣势"></a>RDB劣势</h4><p>1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次的快照后所有的修改</p>
<p>2、fork的时候，内存中的数据被克隆一份，大致2倍的膨胀性需要考虑</p>
<h4 id="如何停止RDB"><a href="#如何停止RDB" class="headerlink" title="如何停止RDB"></a>如何停止RDB</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config <span class="keyword">set</span> <span class="keyword">save</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>





<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">java基础之集合--深入研究</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-09 21:31:38 / 修改时间：15:03:35" itemprop="dateCreated datePublished" datetime="2020-06-09T21:31:38Z">2020-06-09</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/10/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/10/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="java基础之集合"><a href="#java基础之集合" class="headerlink" title="java基础之集合"></a>java基础之集合</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">rabbitmq学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-08 00:23:05" itemprop="dateCreated datePublished" datetime="2020-06-08T00:23:05Z">2020-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-07 20:28:44" itemprop="dateModified" datetime="2020-06-07T20:28:44Z">2020-06-07</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rabbitmq学习"><a href="#rabbitmq学习" class="headerlink" title="rabbitmq学习"></a>rabbitmq学习</h1><p>rabbitmq整体架构就是生产者消费者模型，主要负责接收、存储和转发消息。</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit01.png" alt="rabbimq架构模型"></p>
<h1 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h1><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>就是消息投递方，生产者创建消息，发布到rabbitmq中。<br>消息两部分构成，一个消息体，一个是标签。<br>消息体又称为payload（载体）</p>
<p>消息体是带有业务逻辑的数据比如json字符串，消息标签用来表述消息，比如交换器名称<br>和路由键。生产者把消息根据标签发送到感兴趣的消费者。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>就是消息的接收方<br>消费者连接到rabbitmq服务器，并订阅到队列上。消费者只是消费消息体，<br>消息标签在消费者消费后，不会丢失，消费者也不知道订阅了哪个生产者发送的消息，也没必要知道</p>
<h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><p>消息中间件的服务节点<br>简单的来说就是rabbitmq的服务节点<br>可以看做是rabbitmq的服务器</p>
<p>如下展示的就是消息队列的服务流程</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit02.png" alt="rabbimq架构模型"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>rabbit的mq内部对象，就是用户存储消息里的内容</p>
<p>多个消费者订阅同一个队列，队列里的消息会平均分摊给消费者。</p>
<p>rabbitmq不支持广播的模式，如需要这个需求，需要二次开发。</p>
<h2 id="交换器、路由键、绑定"><a href="#交换器、路由键、绑定" class="headerlink" title="交换器、路由键、绑定"></a>交换器、路由键、绑定</h2><h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p>生产者将消息发送到交换器中，由交换器发送到指定的队列中。<br>可以简单的把交换器看做简单的实体。<br>在rabbitmq中交换器有四种。</p>
<h3 id="RoutingKey路由键"><a href="#RoutingKey路由键" class="headerlink" title="RoutingKey路由键"></a>RoutingKey路由键</h3><p>用来指定消息的路由规则，路由键需要与绑定键绑定后，才可生效。<br>在路由键和绑定建固定的情况下，生产者发送消息到交换器，通过路由来指定消息最终流向哪个队列。</p>
<h2 id="Binding绑定"><a href="#Binding绑定" class="headerlink" title="Binding绑定"></a>Binding绑定</h2><p>通过绑定将交换器与队列关联起来<br><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit03.png" alt="rabbimq架构模型"></p>
<h2 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h2><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>把所有发送到该交换器的消息路由到所有与该交换器绑定的路由。</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>它会把消息路由到那些绑定键和路由键完全匹配的队列中</p>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>它会把消息路由到那些绑定键和路由键匹配的队列中，但是规则有所不同。</p>
<p>.代表分隔符，*匹配一个单词，#匹配多个单词可以是0个单词。</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit04.png" alt="rabbimq架构模型"><br><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit05.png" alt="rabbimq架构模型"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit06.png" alt="rabbimq架构模型"></p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/rabbit07.png" alt="rabbimq架构模型"></p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h2 id="rabbitmq工作模式"><a href="#rabbitmq工作模式" class="headerlink" title="rabbitmq工作模式"></a>rabbitmq工作模式</h2><h3 id="简单工作模式"><a href="#简单工作模式" class="headerlink" title="简单工作模式"></a>简单工作模式</h3><p>一个生产者，一个消费者，整个工作流程中没有交换机</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/p01.png" alt="rabbimq架构模型"></p>
<h3 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h3><p>一个生产者，多个消费者，整个工作流程中没有交换机</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/p02.png" alt="rabbimq架构模型"></p>
<h3 id="发布与订阅模式"><a href="#发布与订阅模式" class="headerlink" title="发布与订阅模式"></a>发布与订阅模式</h3><p>发布订阅模式：<br>    1、每个消费者监听自己的队列。<br>    2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>    到消息</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/p03.png" alt="rabbimq架构模型"></p>
<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>路由模式特点：</p>
<p>1、队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）<br>2、消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。<br>3、Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing<br>      Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/p04.png" alt="rabbimq架构模型"></p>
<h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p>1、Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing<br> key 的时候使用通配符！<br>2、Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p>
<p><img src="/2020/06/08/rabbitmq%E5%AD%A6%E4%B9%A0/p05.png" alt="rabbimq架构模型"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/HTTP%E6%9D%83%E9%99%90%E6%8C%87%E5%8D%97-HTTP%E6%8A%A5%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/HTTP%E6%9D%83%E9%99%90%E6%8C%87%E5%8D%97-HTTP%E6%8A%A5%E6%96%87/" class="post-title-link" itemprop="url">HTTP权限指南--HTTP报文</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-07 00:26:31" itemprop="dateCreated datePublished" datetime="2020-06-07T00:26:31Z">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-13 16:29:10" itemprop="dateModified" datetime="2020-06-13T16:29:10Z">2020-06-13</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/07/HTTP%E6%9D%83%E9%99%90%E6%8C%87%E5%8D%97-HTTP%E6%8A%A5%E6%96%87/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/07/HTTP%E6%9D%83%E9%99%90%E6%8C%87%E5%8D%97-HTTP%E6%8A%A5%E6%96%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>387</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>HTTPS</strong></p>
<p>HTTPS是常见的HTTP安全版本，HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起。特点：安全、灵活。</p>
<p>HTTPS就是在安全层的基础上发送HTTP。</p>
<p>HTTPS将发送给安全层对其进行加密</p>
<p>HTTP安全层通过SSL以及现代替协议TLS来实现的。</p>
<p>HTTP建立安全连接：</p>
<p>客户端打开一条web服务器</p>
<p><strong>HTTP常问面试题</strong></p>
<p>1、Http与Https的区别</p>
<p>默认端口不同，http默认端口80而HTTPS默认端口443，</p>
<p>2、什么是Http协议无状态协议?怎么解决Http协议无状态协议?</p>
<p>3、URI和URL的区别？</p>
<p>4、常用的HTTP方法有哪些？</p>
<p>6、HTTP请求报文与响应报文格式HTTP请求报文与响应报文格式？</p>
<p>7、HTTPS工作原理</p>
<p>8、一次完整的HTTP请求所经历的7个步骤</p>
<p>9、常见的HTTP相应状态码？</p>
<p>10、HTTP1.1版本新特性?</p>
<p>11、HTTP优化方案？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="孙力"
      src="/images/1111.jpg">
  <p class="site-author-name" itemprop="name">孙力</p>
  <div class="site-description" itemprop="description">总结分享的个人博客平台</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sunli1224" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sunli1224" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙力</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">47k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">43 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='34,34,34' opacity='0.5' zIndex='-1' count='200' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'qvQbGCPExeIQolUYwSewntvF-gzGzoHsz',
      appKey: 'vGckBnJ9FwIKD4leKOkFpTUP',
      placeholder: "Just go go",
      avatar: 'monsterid',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
