<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1、面向对象的特征有哪些方面？抽象：抽象是将同一类对象的共同特征构造类的对象，包括数据抽象和行为抽象两个方面，并不关注细节是什么。 继承：继承是从已有的类得到继承信息创建新类的过程。 封装：访问控制和隐藏实现，对外提供接口，隐藏实现细节 多态： 一个类有多种形式（父类的对象引用指向子类的对象） 多态分为两种一个是编译时多态一个是运行时多态。 编译时多态： 1、编译期间决定目标方法 2、通过over">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础面试题">
<meta property="og:url" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="bblike博客小站">
<meta property="og:description" content="1、面向对象的特征有哪些方面？抽象：抽象是将同一类对象的共同特征构造类的对象，包括数据抽象和行为抽象两个方面，并不关注细节是什么。 继承：继承是从已有的类得到继承信息创建新类的过程。 封装：访问控制和隐藏实现，对外提供接口，隐藏实现细节 多态： 一个类有多种形式（父类的对象引用指向子类的对象） 多态分为两种一个是编译时多态一个是运行时多态。 编译时多态： 1、编译期间决定目标方法 2、通过over">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059361002.png">
<meta property="og:image" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059414565.png">
<meta property="og:image" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059719526.png">
<meta property="og:image" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059655560.png">
<meta property="og:image" content="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png">
<meta property="article:published_time" content="2020-06-14T00:19:01.000Z">
<meta property="article:modified_time" content="2021-06-08T16:11:58.756Z">
<meta property="article:author" content="孙力">
<meta property="article:tag" content="java面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059361002.png">

<link rel="canonical" href="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>java基础面试题 | bblike博客小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bblike博客小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

<!-- 加入APlayer音乐播放器 -->
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bblike博客小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">bblikeBoy</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-fw fa-comment"></i>留言版</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1111.jpg">
      <meta itemprop="name" content="孙力">
      <meta itemprop="description" content="总结分享的个人博客平台">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bblike博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 00:19:01" itemprop="dateCreated datePublished" datetime="2020-06-14T00:19:01Z">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 16:11:58" itemprop="dateModified" datetime="2021-06-08T16:11:58Z">2021-06-08</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h3><p><strong>抽象：</strong>抽象是将同一类对象的共同特征构造类的对象，包括数据抽象和行为抽象两个方面，并不关注细节是什么。</p>
<p><strong>继承：</strong>继承是从已有的类得到继承信息创建新类的过程。</p>
<p><strong>封装</strong>：访问控制和隐藏实现，对外提供接口，隐藏实现细节</p>
<p><strong>多态</strong>： 一个类有多种形式（父类的对象引用指向子类的对象）</p>
<p>多态分为两种一个是编译时多态一个是运行时多态。</p>
<p>编译时多态：</p>
<p>1、编译期间决定目标方法</p>
<p>2、通过overloading重载实现</p>
<p>3、方法名相同，参数不同</p>
<p>运行时多态</p>
<p>1、运行期间决定目标方法</p>
<p>2、同名同参</p>
<p>3、overrideing和继承实现</p>
<p>4、JVM决定目标方法</p>
<p>运行时多态实现机制？</p>
<p>在JVM的堆里面的方法区，存着方法表（存放方法的入口地址），</p>
<p>通过invokeVirture指令来找到对应的方法入口。</p>
<h3 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h3><p>泛型对于java语言来说只出现在编译期间，到了运行期，就会出现泛型擦除，就是原有类型全部被擦除。</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunli</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/24 18:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"t001"</span>);</span><br><span class="line">        list.add(<span class="string">"t002"</span>);</span><br><span class="line">        list.add(<span class="string">"t003"</span>);</span><br><span class="line">        list.add(<span class="string">"t004"</span>);</span><br><span class="line">        list.add(<span class="string">"t005"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass = list.getClass();</span><br><span class="line"></span><br><span class="line">        Method method = aClass.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射的方式将不同类型数据能添加到该容器中</span></span><br><span class="line">        method.invoke(list, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时会出现类型转换异常</span></span><br><span class="line">        System.out.println(list.get(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="迭代器模式？"><a href="#迭代器模式？" class="headerlink" title="迭代器模式？"></a>迭代器模式？</h4><p>1、迭代器模式是常用的设计模式，属于行为模式。</p>
<p>2、如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类</p>
<p>或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用各种遍历方式</p>
<p>，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</p>
<p>3、迭代器模式，提供一种遍历集合的统一接口，用一致的方法遍</p>
<p>历集合元素，不需要知道集合对象的底层表示，即不要暴露其内部的结构。</p>
<h3 id="为什么使用redis存储session代替session存储？（谊品生鲜一面）"><a href="#为什么使用redis存储session代替session存储？（谊品生鲜一面）" class="headerlink" title="为什么使用redis存储session代替session存储？（谊品生鲜一面）"></a>为什么使用redis存储session代替session存储？（谊品生鲜一面）</h3><p>​     当项目使用分布式时，session问题就显得比较突出了，因为有不同服务器的缘故，如果你安照一般方式存储session，那么你的session会保存在某一台服务器上，如果你的下一个请求并不是访问这台服务器，那么会发生读取不到session的情况。这种情况的解决方案有许多种，例如你可以采用session sticky的方式，但是这样会对负载均衡器造成相当大的负担，而且某台服务器挂了，会造成session丢失。或者采用session replication方式，但是如果服务器数量一多，是不是就造成了十分庞大的带宽开销，而且，如果有很多客户端同时访问服务器的话，那么每台服务器都需要保存大数量的session数据，而session数据是存储在内存中的，这样每台机器用于保存session数据占用的内存就太多了。还有一种就是采用cookie，不过这种方式是十分不可取了，先不说session数据放到客户端那边造成的安全问题，这样会造成带宽消耗，而且会强烈影响性能，而且cookie自身也有长度限制。而另外一种方式则是session 集中化处理，你可以存在数据库中，也可以采用其他分布式存储系统，这里session的储存引入了网络操作，所以可能会有数据延迟，而且当session储存设备挂了，会造成所有session丢失，不过总体来说，这种session的存储方式是十分明显的。所以这里我们采用redis，nosql的方式进行session存储。 </p>
<h1 id="B树和B-树的区别？"><a href="#B树和B-树的区别？" class="headerlink" title="B树和B+树的区别？"></a>B树和B+树的区别？</h1><p>b树也是多路查找搜索树，它的节点是存储相应的key和value值的</p>
<p>而B+树与B树的区别就是在于叶子节点和非叶子节点的关系</p>
<p>非叶子节点存储key值而叶子节点存储value值，并且叶子节点的</p>
<p>数据是以链表的方式连接的，并且是有序的。</p>
<p>B+树就是解决了B树存在的缺陷，就是会出现回旋查找的问题。</p>
<h1 id="threadLocal-原理"><a href="#threadLocal-原理" class="headerlink" title="threadLocal 原理"></a>threadLocal 原理</h1><p>threadLocal对象可以提供线程局部变量，也就是说每个线程都有一份自己的副本，</p>
<p>多个线程之间相互不干扰，通过initialValue方法来赋值，</p>
<p>我们在第一个访问get方法时，就会给线程赋值，通过initialValue方法来赋值。</p>
<p>在java8中，每个线程对应的thread对象内部都拥有一个threadLocals字段，这个</p>
<p>字段会指向一个threadLocalMap对象，这个对象关联相关的存储的数据。</p>
<h1 id="线程屏障"><a href="#线程屏障" class="headerlink" title="线程屏障"></a>线程屏障</h1><p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059361002.png" alt="1623059361002"></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059414565.png" alt="1623059414565"></p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>1、不保证原子性</p>
<p>2、可见性</p>
<p>3、指令重排</p>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_17-32-08.png)</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_17-33-01.png)</p>
<h1 id="公平锁和非公锁"><a href="#公平锁和非公锁" class="headerlink" title="公平锁和非公锁"></a>公平锁和非公锁</h1><p>公平锁：</p>
<p>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果是空的，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后按照FIFO的规则从队列中取到自己</p>
<p>非公平锁：先尝试占有锁，如果尝试失败，就采用类似公平锁的方式。（在高并发的情况下，有可能造成优先级</p>
<p>反转或者饥饿现象）</p>
<p>synchronized</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会</p>
<p>自动获取锁（锁的对象必须是同一个对象）</p>
<p>不会因为之前已经获取过还没释放而阻塞。</p>
<p>java中ReentranLock和Syncronized都是可重入锁，可重入</p>
<p>锁的一个优点就是可以避免死锁。</p>
<p><strong>Syncronized可重入原理：</strong></p>
<p>每个锁对象都拥有一个计数器和一个指向该持有该锁的线程指针。</p>
<p>当执行monitorenter时，如果目标对象的计数器为零，那么说明</p>
<p>它没有被其他线程所持有，java虚拟机会将该锁对象的持有线程设置</p>
<p>为当前线程，并且将其计数器加1。</p>
<p>在目标对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，</p>
<p>那么java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，java虚拟机则需将锁对象计数器减1.计数器为0代表该</p>
<p>锁已经释放。</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>类似于线程等待唤醒机制（wait/notify）</p>
<p>是用来创建锁和其他同步类的基本线程阻塞原语。</p>
<p>LockSupport中park（）和unpark（）的作用分别是</p>
<p>阻塞线程和解除阻塞线程。</p>
<p>阻塞线程的工具类，可以让线程在任意位置阻塞，阻塞之后也有唤醒的方法，</p>
<p>LockSupprt调用的是unsafe中的native代码。</p>
<p>LockSupprt和每个使用它的线程都有一个许可（permit）。</p>
<p>permit相当于1,0的开关，默认是0，</p>
<p>调用一次unpark就加1变成1，</p>
<p>调用park会消费permit，就是将0变为1，</p>
<p>如果再次调用park就会被阻塞</p>
<p>线程阻塞需要消耗permit，这个凭证最多只有1个。</p>
<p><strong>为什么可以先唤醒线程后，阻塞线程？</strong></p>
<p>因为unpark获得一个凭证，之后再调用park方法，就可以消费，所以</p>
<p>不会阻塞。</p>
<p><strong>为什么唤醒两次之后阻塞两次，但最终结果还会阻塞线程？</strong></p>
<p>因为凭证的数量最多为1，连续调用两次unparkhe调用一次unpark效果</p>
<p>一样，只会增加一个凭证，而调用两次park却要消费两个凭证，证不够，</p>
<p>不能放行。</p>
<p><strong>三种实现等待和唤醒机制的方式？</strong></p>
<p>1、使用Object类中的wait和notify方法实现线程等待和唤醒</p>
<p><strong>注意点：</strong>就是必须要synchronized代码块联合使用</p>
<p>，还有必须先wait再notify，否则会导致线程一直处于阻塞状态。</p>
<p>2、Condition接口中await后signal方法实现线程的等待和唤醒机制</p>
<p><strong>注意点：</strong>就是必须要synchronized代码块联合使用</p>
<p>，还有必须先wait再notify，否则会导致线程一直处于阻塞状态。</p>
<p>3、使用LcokSupport类中的park等待和unpark唤醒</p>
<h1 id="AQS（抽象队列同步器）原理："><a href="#AQS（抽象队列同步器）原理：" class="headerlink" title="AQS（抽象队列同步器）原理："></a>AQS（抽象队列同步器）原理：</h1><p>用来构建锁或者其他同步组件的重量级基础框架及整个JUC体系的基石，通过</p>
<p>内置的FIFP队列来完成资源获取线程的排队工作，并通过一个int类型的变量来</p>
<p>表示锁的状态。</p>
<p>抢到资源的线程直接处理业务逻辑，抢不到资源的必然涉及一种排队等待机制，抢占资源失败的线程继续</p>
<p>去等待，但等待线程任然保留获取锁流程任在继续。</p>
<p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列实现的，</p>
<p>将占时获取不到锁的线程加到队列中，这个队列就是AQS的抽象表现，它将请求共享资源的线程封装成队列</p>
<p>Node，通过CAS、自旋以及LockSupport.park()的方式维护state变量的撞他，使并发达到同步控制的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 共享 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** 独占 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 线程被取消 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 后继线程需要被唤醒 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 等待condition唤醒 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        共享式同步状态获取将无条件地传播下去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        初始为0，状态是上面的几种</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        前置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        Node节点保存的线程对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_16-09-02.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_16-01-58.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-07_15-39-41.png)</p>
<h3 id="用过线程池吗？有哪些线程池？有哪些参数？-（谊品生鲜一面）"><a href="#用过线程池吗？有哪些线程池？有哪些参数？-（谊品生鲜一面）" class="headerlink" title="用过线程池吗？有哪些线程池？有哪些参数？ （谊品生鲜一面）"></a>用过线程池吗？有哪些线程池？有哪些参数？ （谊品生鲜一面）</h3><p><strong>线程池的类型有哪些？</strong></p>
<p> <strong>1、newCachedThreadPool</strong> </p>
<p>创建一个可缓存线程池</p>
<p> <strong>2、newFixedThreadPool</strong> </p>
<p>指定工作线程的线程池</p>
<p> <strong>3、newSingleThreadExecutor</strong> </p>
<p>单线程线程池，只创建工作线程来执行任务</p>
<p> <strong>4、newScheduleThreadPool</strong> </p>
<p>定长的线程池</p>
<p> <strong>5、newSingleThreadScheduledExecutor</strong> </p>
<p> 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。 </p>
<p><strong>使用线程池的优势？</strong></p>
<p>1、降低资源消耗（如线程的上下文切换时，就会创建线程或者销毁线程）</p>
<p>2、提高响应速度，当任务到达时，任务无需等待线程的创建就会立刻执行</p>
<p>3、提高线程管理性</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-05-27_14-29-18.png)</p>
<p><strong><em>线程池执行流程</em></strong></p>
<p>![](D:\npm Registry\ss\source_posts\JVM学习\Snipaste_2021-05-26_13-26-19.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize 线程池的基本大小</span><br><span class="line">    </span><br><span class="line">runnableTaskQueue: 用于保存等待执行的任务阻塞队列</span><br><span class="line">     ArrayBlockingQueue: 一个基于数组的阻塞队列（先进先出）</span><br><span class="line">     LinkedBlockingQueue: 一个基于链表结构的阻塞队列，吞吐量高于基于数组的阻塞队列</span><br><span class="line">     synchronousQueue: 一个不存储元素的阻塞队列。每个插入操作都必须等到另一个线程调用移除</span><br><span class="line">         操作，否则插入操作一直处于阻塞状态，吞吐量高于基于链表的阻塞队列</span><br><span class="line">     priorityBlockingQueue: 一个具有优先级的无线循环阻塞队列</span><br><span class="line">         </span><br><span class="line">maximumPoolSize：线程池最大数量，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数</span><br><span class="line">         小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果适用了无界阻塞队列</span><br><span class="line">         这个参数的设置就是无效的。</span><br><span class="line">ThreadFactory：用于创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置名称。</span><br><span class="line">         </span><br><span class="line">RejectedExecutionHandler: 当队列和线程池都满了，说明线程池处于饱和状态，那么就必须采取一种策略</span><br><span class="line">    处理提交的新任务。这个策略默认情况下AbortPolicy，表示无法处理新任务时抛出异常。</span><br><span class="line">    </span><br><span class="line">    AbortPolicy： 直接抛出异常</span><br><span class="line">    callerRunsPolicy：只用调用者所在线程来运行任务</span><br><span class="line">    DiscardOldestPolicy: 丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">    DiscardPolicy：不处理，丢弃掉。</span><br><span class="line">        </span><br><span class="line">    自定义一个 RejectedExecutionHandler 接口自定义处理策略，如记录日志</span><br><span class="line">    或持久化存储不能处理的任务。</span><br><span class="line">        </span><br><span class="line">keepAliveTime：线程池的工作线程空闲后，保持存活的时间。所以如果</span><br><span class="line">        任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的</span><br><span class="line">        利用率。</span><br><span class="line">        </span><br><span class="line">TimeUnit：线程活动保持时间的单位</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>线程池拒绝策略</strong></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059719526.png" alt="1623059719526"></p>
<p><strong>合理配置线程池？</strong></p>
<p><img src="/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1623059655560.png" alt="1623059655560"></p>
<p>1、任务性质</p>
<p>2、任务优先级</p>
<p>3、任务执行长短</p>
<p>4、任务是否具有依赖性</p>
<p>1、性质不同的任务可以用不同规模的线程池分开处理</p>
<p>2、如果根据优先级去考虑的话，可能要使用无界阻塞队列</p>
<p>因为他会根据任务优先级的高低来优先处理任务</p>
<p>3、执行时间不同的任务可以交给不同规模的线程池来处理，或者使用</p>
<p>优先级队列处理时间短的任务。</p>
<p>4、如果任务依赖于数据库，因为线程提交sql后需要等待数据库返回</p>
<p>结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置的</p>
<p>越大，这样才能更好地利用cpu。</p>
<p>5、建议使用有界队列</p>
<h3 id="Java包装器类的作用"><a href="#Java包装器类的作用" class="headerlink" title="Java包装器类的作用"></a>Java包装器类的作用</h3><p>1 类里有相应方法方便用户调用</p>
<p>2 可以用类的对象和null进行比较，避免java.lang.nullPointException</p>
<h4 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a><strong>springboot自动配置原理</strong></h4><p>在springboot 启动工程类中，注解为@SpringBootApplication的实现类中，里面有一个注解@EnableAutoConfiguation的实现类中，它将AutoConfigurationImportSelector这个类通过注解@Import加载到IOC容器中，这个类实现了DeferredImportSelector, BeanClassLoaderAware这两个接口，它会将它EnableAutoConfiguration.class加载进来，会将META-INF/spring.factories这个文件中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，value为springboot的默认的配置类加载到IOC容器中，但是每个配置类里面都会有一些加载条件，如果不满足就无法将配置类加载到IOC容器中。</p>
<h4 id="java反射技术"><a href="#java反射技术" class="headerlink" title="java反射技术"></a>java反射技术</h4><p>反射技术是动态语言的关键，反射机制允许程序在执行期借助于Reflection API，取得任何类的内部消息，并能直接操作任意对象的内部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象就包含了完整的类结构信息，我们可以通过这个类的结构。</p>
<p>正常方式获取对象的方法和属性： 创建对象实例  获取对象的信息</p>
<p>反射方式： 实例化对象  — getClass()方法   — 得到完整的包类名称</p>
<h4 id="java注解原理"><a href="#java注解原理" class="headerlink" title="java注解原理"></a>java注解原理</h4><h4 id="springboot启动原理"><a href="#springboot启动原理" class="headerlink" title="springboot启动原理"></a>springboot启动原理</h4><h1 id="redis-底层数据结构之跳跃表"><a href="#redis-底层数据结构之跳跃表" class="headerlink" title="redis 底层数据结构之跳跃表"></a>redis 底层数据结构之跳跃表</h1><p>跳跃表（<a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener external nofollow noreferrer">skiplist</a>）是一种随机化的数据， 由 William Pugh 在论文<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noopener external nofollow noreferrer">《Skip lists: a probabilistic alternative to balanced trees》</a>中提出， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p>
<p>以下是个典型的跳跃表例子（图片来自<a href="http://en.wikipedia.org/wiki/File:Skip_list.svg" target="_blank" rel="noopener external nofollow noreferrer">维基百科</a>）：</p>
<p><a href="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png" target="_blank" rel="noopener external nofollow noreferrer"><img src="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png" alt="../_images/skiplist.png"></a></p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li>
</ul>
<p>因为跳跃表的定义可以在任何一本算法或数据结构的书中找到， 所以本章不介绍跳跃表的具体实现方式或者具体的算法， 而只介绍跳跃表在 Redis 的应用、核心数据结构和 API 。</p>
<h1 id="arraryList扩容"><a href="#arraryList扩容" class="headerlink" title="arraryList扩容"></a>arraryList扩容</h1><p>每次插入时，都会判断容器的容量是否能存放完待插入的数据，如果不能则，</p>
<p>将容器扩容为原来的1.5倍</p>
<h1 id="hashMap-原理"><a href="#hashMap-原理" class="headerlink" title="hashMap 原理"></a>hashMap 原理</h1><p>（扩容机制、负载因子、红黑树、散列表等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16  散列表中数组的初始容量大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 散列表最大容量2的31次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 链表转换为红黑树的阀值（当链表的大小为8时，转为红黑树）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">// 红黑树降级为链表的阀值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; </span><br><span class="line"><span class="comment">// 树化的另一个参数，</span></span><br><span class="line"><span class="comment">// 当哈希表中所有元素超过64时，才会允许将链表结构转换为红黑树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">// hash值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="comment">// key值</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="comment">// value值</span></span><br><span class="line">        V value;</span><br><span class="line">       <span class="comment">// 下一个节点的值</span></span><br><span class="line">        Node&lt;K,V&gt; next;   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashMap的属性介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash表， 什么时候初始化？</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前hash表中元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前哈希表结构修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阀值， 当哈希表中的元素超过阀值时，触发扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阀值、负载因子、散列表容量关系？</span></span><br><span class="line"><span class="comment">// threshold = loadFactor * capacity</span></span><br><span class="line"><span class="comment">// 例子： threshold = 16 * 0.75f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashMap 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化容量不能为小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 初始化容器的值不能大于最大容量大小</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">// 负载因子不能为小于等于0，并且是float类型的数字</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 扩容阀值赋值</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">扩容阀值赋值</span></span><br><span class="line"><span class="comment">返回一个大于等于当前cap的一个数字，</span></span><br><span class="line"><span class="comment">且必须是2的次方数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种算法就是保证返回出来的值是2的次方数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">扰动函数</span></span><br><span class="line"><span class="comment">让key的hash值的高16位也参与路由运算。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tab 引用当前hash表</span></span><br><span class="line">        <span class="comment">// p 表示当前散列表的元素</span></span><br><span class="line">        <span class="comment">// n 表示散列表的长度</span></span><br><span class="line">        <span class="comment">// i 路由寻址结果</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hashMap会延迟初始化，只有put的时候，才会开辟内存，存储数据，这样不会浪费内存</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 寻址找到的桶为为null，这个时候就可以将value值直接存放到该桶位中</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// e node临时元素</span></span><br><span class="line">            <span class="comment">// k 表示临时的一个key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="mysql-ACID执行原理"><a href="#mysql-ACID执行原理" class="headerlink" title="mysql ACID执行原理"></a><strong>mysql ACID执行原理</strong></h1><p>mysql 的acid指的是 原子性、持久性、隔离性、一致性</p>
<p><strong>原子性：</strong> </p>
<p>mysql实现原子性，是通过undo.log日志实现的，mysql在执行事务操作的时候，</p>
<p>都会生成undo.log日志，将执行的sql语句记录到undo.log中，如果发生错误，导致回滚操</p>
<p>作的时候，都会将读取undo.log的语句，将执行过的语句，执行相反的操作，回滚回初始状态，</p>
<p>比如执行插入语句了，回滚时就执行删除操作、发生了更新操作，回滚时就会朝相反的更新操作</p>
<p>去执行回滚操作。</p>
<p><strong>持久性：</strong> </p>
<p>mysql持久性，也是通过日志记录形式实现的，通过redo.log日志实现的，mysql的持久化，通过缓存</p>
<p>buffer的方式来提高效率，即在查询数据时，先去查缓存buffer的数据，如果没有查询到数据，就会</p>
<p>查询磁盘IO的数据，然后将查询的数据同步到缓存buffer中；在做更新操作时，先更新缓存buffer中的数据</p>
<p>，然后再更新磁盘的操作，这些操作的目的就是通过缓存的方式，减少磁盘IO的次数，提高效率。但是这会</p>
<p>带来一个问题就是如果在操作过程中，mysql发生了宕机，那么缓存中的数据就会消失，在做更新操作时，先会</p>
<p>更新磁盘，然后更新磁盘IO，这个时候就会导致数据有丢失情况，为了解决这个问题，就需要使用redo.log，在</p>
<p>执行修改操作时，sql会先写到redo.log日志中，当事务提交时，就会将redo日志同步写到磁盘中，这样即使发生宕机情况，也会通过redo.log保证数据不丢失，达到持久性的效果。</p>
<p><strong>隔离性：</strong></p>
<p>隔离性的意思就是mysql在多个事务执行时，不能相互影响</p>
<p>这就涉及到两个方面一个是写写操作另一个就是读写操作了，</p>
<p>写写操作就是通过加上锁的方式去保证两个事务的隔离性，</p>
<p>而读写操作，就是通过mvcc来解决（包括脏读、不可重复读、幻读）</p>
<p><strong>一致性：</strong></p>
<p>事务在执行前后数据库的状态都是正常的，表现为没有违反数据完整性，</p>
<p>参照完整性和用户自定义完整性，而原子性、持久性、隔离性就是保证</p>
<p>数据库具有一致性。</p>
<h1 id="mysql的-mvcc"><a href="#mysql的-mvcc" class="headerlink" title="mysql的 mvcc"></a>mysql的 mvcc</h1><p>mvcc意思就是多版本控制，</p>
<p>同一行数据发生读写请求时，会上锁阻塞，但是mvcc用更好的方式来处理读写请求，做到在发生读写请求冲突时不用加锁。</p>
<p>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁</p>
<p><strong>什么是当前读？什么是快照读？</strong></p>
<p>当前读：</p>
<p>它读取的数据库记录，都是最新的版本，会对当前读取的数据</p>
<p>进行加锁，防止其他事务修改数据，是一种悲观锁的操作。</p>
<p>select lock in share mode (共享锁)</p>
<p>select for update （排它锁）</p>
<p>update （排它锁）</p>
<p>insert （排它锁）</p>
<p>delete （串行化）</p>
<p>串行化事务隔离级别</p>
<p>快照读：</p>
<p>快照读的实现是基于多版本并发控制， 即mvcc，既然是多版本，</p>
<p>那么快照读读到的数据不一定是当前最新的数据，有可能是之前</p>
<p>历史版本的数据。</p>
<p>mysql的innodb的隔离级别</p>
<p>1、读已提交</p>
<p>2、读未提交</p>
<p>3、可重复读</p>
<p>4、串行化</p>
<p>串行化是通过当前读实现的，是事务和事务间</p>
<p>是通过加锁的方式来读写操作、写写操作的，</p>
<p>所以执行效率很低，一般不采取这种隔离级别。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_19-22-50.png)</p>
<p>undo日志是用来记录历史数据的，比如一条记录修改了好几次，这些历史数据就会被存储到 </p>
<p>undo.log中，每条数据，不仅包含数据本生之外，还包含存储了事务ID和回滚指针，事务ID</p>
<p>是自增的，回滚指针指向上条记录的头结点。</p>
<p><strong>版本链：</strong>指的是undo.log和回滚指针连接起来的。</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_21-56-52.png)</p>
<p><strong>ReadView（快照）</strong></p>
<p><strong>作用：</strong> 是一个查询语句，判断查询的是哪条记录，在undo.log中。</p>
<p><strong>注意：</strong></p>
<p><strong>参数m_ids：</strong> 指的是未提交的事务ID</p>
<p><strong>ReadView如何判断版本链中哪个版本可用？</strong></p>
<p>trx_id（当前事务ID） == creator_id（readView存储的事务ID）: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 可以访问这个版本</p>
<p>trx_id &lt; min_trx_id: 不可以访问这个版本</p>
<p>min_trx_id  &lt;= trx_id &lt;= max_trx_id: 如果trx_id在m_ids中是不可以访问这个版本的，</p>
<p>反之可以</p>
<p><strong>抽象视图：</strong></p>
<p>已提交事务  – <strong>min_id</strong> –  未提交与已提交事务 – <strong>max_id</strong> – 未开始事务</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-37-40.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-11.png)</p>
<p>![](D:\npm Registry\ss\source_posts\java基础面试题\Snipaste_2021-06-06_22-38-50.png)</p>
<h1 id="dubbo的负载均衡策略"><a href="#dubbo的负载均衡策略" class="headerlink" title="dubbo的负载均衡策略"></a>dubbo的负载均衡策略</h1><p>1、random</p>
<p>随机算法，是dubbo默认的负载均衡策略，在多态机器上的服务随机</p>
<p>取一台服务进行调用，如果各个机器性能没有太大差异的情况下，可以采取这种策略。</p>
<p>但是这种策略可能导致服务堆积问题。</p>
<p>2、roundrobin</p>
<p>轮询算法，多态机器上的服务按照请求顺序依次轮着调用，保证一定得公平性，实际使用</p>
<p>的时候可以按照设定好的权重依次进行调度，这样避免性能差的服务器出现大面积的服务调用超时情况。</p>
<p>3、leastactive</p>
<p>最少活跃调度算法，即被调度次数越少，其优先级就越高，被调度到的几率就越高。</p>
<p>4、consistenthash</p>
<p>一致性hash算法，对于相同参数的请求，其会被路由到相同的提供者，</p>
<p>可以根据请求的IP地址进行hash，或者请求参数，或者某个业务参数等</p>
<p>进行hash取值，一致性hash在Nginx集群做网关配置时也有此用法。</p>
<h1 id="Spring传播范围"><a href="#Spring传播范围" class="headerlink" title="Spring传播范围"></a>Spring传播范围</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. PROPAGATION_REQUIRED  支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </span><br><span class="line"><span class="number">2</span>. PROPAGATION_SUPPORTS  支持当前事务，如果当前没有事务，就以非事务方式执行。 </span><br><span class="line"><span class="number">3</span>. PROPAGATION_MANDATORY  支持当前事务，如果当前没有事务，就抛出异常。 </span><br><span class="line"><span class="number">4</span>. PROPAGATION_REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。 </span><br><span class="line"><span class="number">5</span>. PROPAGATION_NOT_SUPPORTED  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </span><br><span class="line"><span class="number">6</span>. PROPAGATION_NEVER  以非事务方式执行，如果当前存在事务，则抛出异常。 </span><br><span class="line"><span class="number">7</span>. PROPAGATION_NEST   新起一个事务，但是内嵌并与已存在的外部事务，如果外部事务回滚，则此事务也会回滚</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢老板！！</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="孙力 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="孙力 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>孙力
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2020/06/14/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" title="java基础面试题">http://yoursite.com/2020/06/14/java基础面试题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E9%9D%A2%E8%AF%95/" rel="tag"># java面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/12/java%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/" rel="prev" title="java并发学习">
      <i class="fa fa-chevron-left"></i> java并发学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/23/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="next" title="mysql性能优化">
      mysql性能优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、面向对象的特征有哪些方面？"><span class="nav-number">1.</span> <span class="nav-text">1、面向对象的特征有哪些方面？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是泛型擦除？"><span class="nav-number">2.</span> <span class="nav-text">什么是泛型擦除？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器模式？"><span class="nav-number">2.1.</span> <span class="nav-text">迭代器模式？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用redis存储session代替session存储？（谊品生鲜一面）"><span class="nav-number">3.</span> <span class="nav-text">为什么使用redis存储session代替session存储？（谊品生鲜一面）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B树和B-树的区别？"><span class="nav-number"></span> <span class="nav-text">B树和B+树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#threadLocal-原理"><span class="nav-number"></span> <span class="nav-text">threadLocal 原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程屏障"><span class="nav-number"></span> <span class="nav-text">线程屏障</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number"></span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM内存模型"><span class="nav-number"></span> <span class="nav-text">JMM内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS"><span class="nav-number"></span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#公平锁和非公锁"><span class="nav-number"></span> <span class="nav-text">公平锁和非公锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可重入锁"><span class="nav-number"></span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LockSupport"><span class="nav-number"></span> <span class="nav-text">LockSupport</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS（抽象队列同步器）原理："><span class="nav-number"></span> <span class="nav-text">AQS（抽象队列同步器）原理：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用过线程池吗？有哪些线程池？有哪些参数？-（谊品生鲜一面）"><span class="nav-number">1.</span> <span class="nav-text">用过线程池吗？有哪些线程池？有哪些参数？ （谊品生鲜一面）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java包装器类的作用"><span class="nav-number">2.</span> <span class="nav-text">Java包装器类的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#springboot自动配置原理"><span class="nav-number">2.1.</span> <span class="nav-text">springboot自动配置原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java反射技术"><span class="nav-number">2.2.</span> <span class="nav-text">java反射技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java注解原理"><span class="nav-number">2.3.</span> <span class="nav-text">java注解原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springboot启动原理"><span class="nav-number">2.4.</span> <span class="nav-text">springboot启动原理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis-底层数据结构之跳跃表"><span class="nav-number"></span> <span class="nav-text">redis 底层数据结构之跳跃表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arraryList扩容"><span class="nav-number"></span> <span class="nav-text">arraryList扩容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hashMap-原理"><span class="nav-number"></span> <span class="nav-text">hashMap 原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql-ACID执行原理"><span class="nav-number"></span> <span class="nav-text">mysql ACID执行原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql的-mvcc"><span class="nav-number"></span> <span class="nav-text">mysql的 mvcc</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dubbo的负载均衡策略"><span class="nav-number"></span> <span class="nav-text">dubbo的负载均衡策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring传播范围"><span class="nav-number"></span> <span class="nav-text">Spring传播范围</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="孙力"
      src="/images/1111.jpg">
  <p class="site-author-name" itemprop="name">孙力</p>
  <div class="site-description" itemprop="description">总结分享的个人博客平台</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sunli1224" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sunli1224" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙力</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">45k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">40 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='34,34,34' opacity='0.5' zIndex='-1' count='200' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'qvQbGCPExeIQolUYwSewntvF-gzGzoHsz',
      appKey: 'vGckBnJ9FwIKD4leKOkFpTUP',
      placeholder: "Just go go",
      avatar: 'monsterid',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
